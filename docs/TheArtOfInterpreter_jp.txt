
インタープリターの技術、あるいはモジュラー性についての複雑さ（第0部、第1部、第2部）

著
ガイ・ルイス・スティール・ジュニア、ジェラルド・ジェイ・サスマン

1978年5月


概要
様々な言語設計上の決定が、その言語のユーザが利用可能なプログラミングスタイルに及ぼす影響を、特にモジュラーシステムを漸進的に構築する能力に重点を置いて検討する。各ステップにおいて、検討中の言語の対話的なメタ循環インタプリタを示す。それぞれの新しいインタープリターは、以前のインタープリターに対する漸進的な変更の結果である。
我々は、様々な変数バインディングの規律と副作用の導入の結果を探索する。動的スコープは手続き的抽象化の構築には適さないが、副作用の構造化された形態であり、モジュール化の要因として別の役割を持つことがわかった。
また、より一般的な副作用も、モジュラー・スタイルを促進するために必要であることがわかった。我々は、副作用の概念と等号（オブジェクトの同一性）の概念は相互に制約し合うものであり、一方を定義することは他方を定義することであることを発見した。
我々が展示するインタープリタは、すべてLISPの簡単な方言で書かれており、すべてLISPライクな言語を実装している。これらのインタープリターのサブセットは、LISPの実際の進化を部分的に歴史的に再構成したものである。

キーワード：抽象化、アクター、適用順序、バインディング、制御構造、デバッグ、動的スコープ、環境、流体変数、FUNARG問題、関数型オブジェクト、対話型プログラミング、ラムダ計算、レキシカル・スコープ、LISP、モジュール性、手続き型データ、再帰方程式、参照透明性、SCHEME、副作用、静的スコープ、構造化プログラミング

本レポートは、ナサチューセッツ工科大学の人工知能研究所で行われた研究について述べたものである。この研究所の人工知能研究に対する支援の一部は、国防総省の高等研究計画局（Advanced Research Projects Agency）から、海軍研究局（Office of Naval Research）との契約N00014-75-C-0643の下で提供されている。


Contents
Introduction
	Modularity
	LISP-like Languages
	Structure of the Paper
Part Zero - LISP and Interpreters
	Recursion Equations
	An Interpreter for LISP Recursion Equations
Part One - Variable Scoping Disciplines
	Procedures as Data
	Local Procedures
	Lexical Scoping
	Top Levels versus Referential Transparency
Part Two - State
	Decomposition of State
	Side Effects and Local State
	Side Effects in the Interpreter
	Equipotency of SETQ and RPLACA
	Side Effects and Equality
	Dynamic Scoping as a State-Decomposition Discipline
Summary
Acknowledgements
Notes
	{Can George do Better?}
	{Debugging}
	{Driver Loop with Side Effects}
	{EVALQUOTE }
	{Gaussian}
	{LABELS}
	{LABELS with Side Effects} *
	{Primitive Operators}
	{PROGN Wizardry )
	{QUOTE Mapping}
	{QUOTE Shafts the Compiler}
	{RPLACA Can Alter CAR Instead}
	{S-expression Postulates and Notation}
	{This ain't A-lists}
	{Value Quibble}
	{Weber}
	{Y-operator}
References





# はじめに

## モジュラリティ

プログラミングによって構築されるものは非常に複雑である。この複雑さを制御する特別なテクニックがなければ、大規模なプログラムを正確に構築することは不可能である。このようなテクニックのほとんどは、問題をほぼ独立に分解する方法を見つけることに基づいている。プログラミング問題を管理可能な断片に分解することに成功する限り、その結果得られるプログラムはモジュール化されていると言える。よく設計されたプログラミング言語は、モジュール化されたプログラムの構築をサポートする機能を備えている。
分解戦略のひとつは、言語の一般的な使用パターンをパッケージ化することである。例えば、Algolのforループは、if文とgoto文の共通パターンを捉えている。共通パターンのパッケージは、必ずしもタイピングを節約するための単なる省略形ではない。単純な省略形は、その省略形が何に展開されるかをユーザが知っていなければならないため、抽象化する力はほとんどありませんが、優れたパッケージは、その実装とは独立した意味を持つより高度な概念をカプセル化します。ひとたびパッケージが構築されれば、プログラマはそのパッケージに含まれる詳細を気にすることなく、直接それを使用することができる。
パッケージは、その動作が使用するコンテキストに依存せず、他のパッケージとの干渉の可能性を減らすことができれば、最も有用である。直感的に言うと、参照透過性とは、プログラムの各部分の意味が明白であり、変化しないことであり、そのような意味が確実に信頼できることである。特に、あるモジュール内部の名前は、他のモジュールに影響を与えたり、影響を受けたりすべきではなく、モジュールの外部動作は、そのローカル識別子の名前の選択とは無関係であるべきです。
モジュール化されたプログラムを作るには、計算プロセスをステート（状態）を持つものとして考える必要がある。このような場合、ステートが自然に独立した部分に分割できるのであれば、重要な分割は、ステートの部分を個別に処理する部分にプログラムを分割することである。
ここでは、モジュール化を実現するための様々な様式的技法について説明する。これらの技法は互いに補完し合うものと思われる。しかし、私たちはその代わりに、それらが対立する可能性があることを発見するだろう。ある言語で1つを極端に推し進めると、他が著しく損なわれる可能性がある。



## LISP ライクな言語 

何百、何千と発明されてきたコンピュータ言語の中で、1950年代後半にマッカーシーらによって開発されたオリジナルのLISPを共通の祖先とする、ある特定の言語ファミリーがある。[ LISP History ] これらの言語は一般的に、シンプルで完全に括弧で囲まれた（"ケンブリッジ・ポーランド語"）構文、一般的なリンクリストデータ構造を操作する能力、これらの構造による言語プログラムの標準表現、および標準表現のインタプリタに基づく対話型プログラミングシステムを特徴としている。このような言語の例としては、LISP 1.5 [LISP 1.5M]、MacLISP [Moon]、InterLISP [Teitelman]、CONNIVER [McDermott and Sussman]、QA4 [Rulifson]、PLASMA [Smith and Hewitt] [Hewitt and Smith]、SCHEME [SCHEME] [Revised Report]などがある。このファミリーをLISP系言語と呼ぶことにする。
このファミリーのさまざまなメンバーは、いくつかの興味深い、そしてしばしば微妙な点で異なっている。これらの違いは、それぞれが推奨またはサポートするプログラミングのスタイルに大きな影響を与える。ここでは、LISPライクな言語システムの実際の製品版で提供されているような「余分な機能」を使わずに、これらの違いを示す一連の小さな（「おもちゃの」）評価器を調べることで、これらの違いのいくつかを探ります。
検討する一連の評価器は、部分的に、このファミリーが進化してきた道筋と思われるものを再構築したものである。これらの道筋は、言語に対する歴史的な変化を、モジュール性のさまざまな側面の要求によって導かれたとみなすことによって、事後的に説明することができる。


## 論文の構成

我々の議論はいくつかの部分に分かれており、それらは直線的な流れを形成している。さらに、興味深い副次的な展開を探るために、数多くの大きな余談がある。これらの脱線は、本文と相互参照しながら、注として末尾に配置されている。
同じコードを何度も書くのを避けるため、各図は異なるルーチンのみを示し、その図に欠けているルーチンが引き出される前の図への相互参照も含んでいる。
第0部では、ここで紹介する例のほとんどが書かれているLISP言語の限定方言を紹介する。また、インタプリタの基本構造について論じ、この言語のメタ循環インタプリタを紹介する。
第1部では、抽象化メカニズムとして手続きデータを導入し、それが言語の変数スコープ領域に与える影響を考察する。予期せぬ相互作用が発見され、修正されるにつれ、我々はそのような一連の規律を強制される。動的スコープとレキシカル・スコープのインタプリタが示される。
第2部では、ステートの分割に関連する問題を検討する。このような分割を実現するメカニズムとして、副作用が導入されている。副作用の概念は同一性の概念と表裏一体であることがわかる。動的スコープは、限定された種類の副作用として見なされている。
以上、まだ答えの出ていない多くの興味深い疑問についてまとめ、結論を述べる。
第3部（別稿）では、副作用の導入により、式の評価順序の問題に迫られることに気づくだろう。call-by-nameとその変種をcall-by-valueと対比させ、パッケージングの異なるモデルの結果として、これらの制御分野がどのように生じるかを議論する。特に、call-by-nameは、Algol 60のコピールールの構文的性質から自然に発生する。前回と同様に、これらの分野のための多くの小さなインタープリタが展示される。
第4部では、構文パッケージの概念を一般化する。手続きの表現を扱うメタ手続きについて議論する。手続きとその表現との区別をより注意深く検討する。マクロ・プロセッサ、代数的単純化器、コンパイラをメタ手続きとして考える。様々なインタープリタ、コンパイラ、単純化器を展示する予定である。




# 第零部 LISPとインタープリタ 

## 再帰式

一般に信じられていることに反して、LISPはもともとChurchのλ-calculus [Church] [LISP History]から派生したものではない。初期のLISPは、自由変数や手続きオブジェクトの概念が明確に定義されていなかった。初期のLISPプログラムは再帰式に似ており、記号式（"S式"）に関数を定義していた。純粋な再帰関数論[Kleene]の方程式とは異なり、「パターン指向の呼び出し」を避けるために、条件式の構成（しばしば「マッカーシー条件式」と呼ばれる）を導入していた。つまり、再帰関数理論では階乗関数を次の2つの式で定義した： 

factorial(0) = 1 
factorial(successor(x)) = successor(x)*factorial(x) 

しかし、初期のLISPでは、こう書いていた：

factorial[x] = [x=0 → 1; T→ x*factorial[x-1]] 

ここで"[a→b; T→ c]"は本質的に "if a then b else c "を意味する。再帰関数理論のバージョンは、左辺に引数をマッチさせることによって2つの方程式のどちらを使うかを選択することに依存する（このような規律はPROLOG言語[Warren]で実際に使われている）。初期のLISPバージョンは、この決定を条件式として表現している。
再帰式の理論は自然数上の関数を扱う。一方LISPでは、代数式、プログラム、その他の記号式をデータ構造として操作することに関心がある。このような式は（クルト・ゲーデルが開発した「算術化」の技法を使って）数値として符号化することができるが、そのような符号化はあまり便利ではない。その代わりに、「S式」（「記号式」の意）と呼ばれる新しい種類のデータが、便利な記号化を提供するために特別に導入された。S式は、自然数の定義に使われるペアノ定理のような形式的帰納的公理によって定義することができる。ここでは、S式の非公式で不完全な定義のみを示す。より完全な説明については、（S式の定理と表記に注意）を参照のこと。
我々の目的には、アトムとリストと呼ばれるS式の特殊なケースだけが必要である。アトムは " 分けられない " データ・オブジェクトであり、文字と数字の文字列で表す。数字だけの場合、アトムは数字とみなされる。"-"や "+"などの多くの特殊文字は文字とみなされる。演算子記号として使用するために特別に確保する必要がないことは後述する。リストはS式の（空の可能性もある）列であり、括弧と空白で区切られたS式を順番に書くことで表記される。アトム "FOO"、"43"、"BAR "のリストは"(FOO 43 BAR) "と書く。リストの定義は再帰的であることに注意。例えば 

(DEFINE (SECOND X) (CAR (CDR X))) 

は3つの要素のリストである。アトム記号DEFINE、2つのアトム記号SECONDとxのリスト、そしてその他の2つの要素のリストである。
S式を使って代数的な式を表現するには、"ケンブリッジ・ポーランド "記法を使う、要するにポーランド記法の接頭辞を括弧でくくったものである。数値定数は数値アトムとして記号化され、変数は非数値アトム（以後アトム記号と呼ぶ）として記号化され、手続き呼び出しはリストとして記号化される。リストの最初の要素は手続きを表し、残りはその引数を表す。例えば、代数式 "a*b+c*d "は"(+ (* a b) (* c d)) "と表すことができる。LISPでは、掛け算と足し算のどちらが先に実行されるかに関する通常の優先順位規則は必要なく、括弧が順序を明確に定義していることに注意してください 。また、引数の数に関係なく、すべての手続き呼び出しは統一された構文を持つ。従って、"Jp(x^2+1) "という式は"(J p (+ (* × 2) 1)) "と書かれる。
条件式を記号化するには 

[p_1 → e_1; p_2 → e_2; ... ; p_N → e_N]

(これは、述語p_jを真が見つかるまで順にaまで評価し、その時点でe_jの値を条件式の値とすることを意味する)S式は次のように書く。

(COND (P1 e1) (p2 e2) ... (pn en))

LISP再帰式の集まりをS式として表現できるようになった。式 

factorial[x] = [x=0 → 1; T→ x*factorial[x-1]]

をS式で表す。

(DEFINE (FACTORIAL X)
           (COND ((= X 0) 1)
                 (T (* X (FACTORIAL ( X 1))))))


(以下のように書くこともできる。 

(DEFINE (FACTORIAL X) (COND ((=
X 0) 1) (T (* X (FACTORIAL (- X
1))))))

しかし、S式は読みやすいようにレイアウトするのが慣例である)。
これで代数式とLISP再帰式をS式で完全に表現できるようになった。このようなS式を用いて、代数式の値を決定するような有用な処理を行うLISPプログラムを書きたいとする。S式を区別し、分解し、組み立てる処理が必要である。
述語ATOMをS式に適用すると、アトムが与えられたときに真を、そうでないときに偽を生成する。空リストはアトムとみなされる。述語NULLは、空リストに対してのみ真であり、その引数はリストである必要はなく、任意のS式でよい。述語NUMBERPは、数に対して真であり、アトムシンボルとリストに対して偽である。述語EQは、2つのアトム記号に適用されたとき、2つのアトム記号が同一であれば真である。これは、アトム記号とその他のS式に適用されると偽となる。(2つのリストに対するEQはまだ定義していない。これは副作用について議論するまでは重要ではないし、意味もないだろう)。
リストに対する分割演算子は、歴史的な理由から伝統的にCARとCDRと呼ばれています。[ LISP History] CARはリストの最初の要素を抽出し、CDRは最初の要素以外のすべての要素を含むリストを生成します。CARとCDRの組み合わせはLISPでよく使われるため、省略形が用意されている。例えば、「(CDR (CDR (CAR (CDR X)))」は「(CDDADR X)」と書くことができる。）
構築演算子CONSは、S式とリストが与えられると、carがS式でcdrがリストである新しいリストを生成します。LIST演算子は任意の数の引数を取ることができ（特別な機能）、引数のリストを生成する。
これでLISPでS式を扱う面白いプログラムが書けるようになった。例えば、2つのS式が同じCAR-CDR構造を持つかどうかを判定する述語EQUALを書くことができる： 


(DEFINE (EQUAL X Y)
           (COND ((NUMBERP X)
                  (COND ((NUMBERP Y) (= X Y))
                        (T NIL)))
                 ((ATOM X) (EQ X Y))
                 ((ATOM Y) NIL)
                 ((EQUAL (CAR X) (CAR Y))
                  (EQUAL (CDR X) (CDR Y)))))

ここでは、TとNILという標準的な名前を使って真と偽を表している。(伝統的にNILは空リストとも考えられているが、ここではこれを避け、空リストには"()"と書くことにする)。
LISPのプログラムはLISPのデータ構造（S式）として表現されるため、定数を表現する際に難しい点がある。例えば、変数xの値がアトム記号 "FOO "であるかどうかを判定したいとする。次のように書いてみよう：

(EQ X FOO)

これはうまくいかない。"FOO "の出現は、アトム記号FOOを定数として参照するのではなく、"x"と同様に変数として扱われる。
本質的な問題は、プログラムではどんなS式でも定数として書けるようにしたいが、S式の中には変数や 手続きの呼び出しなど、他のものを表すのに使わなければならないものもあるということだ。この問題を解決するために、私たちは新しい表記法を考案した。プログラム中の(QUOTE x)は定数S式xを表している。{Note QUOTE Mapping} したがって、私たちはテストを"(EQ X (QUOTE FOO)) "と書くことができる。同様に 

(EQUAL X (LIST Y Z))

では、yとzの値からリストを作成し、その結果をxの値と比較する。一方

(EQUAL X (QUOTE (LIST Y Z))) 

はxの値を定数S式"(LIST Y Z)"と比較する。LISPではQUOTE構文が頻繁に使用されるため、省略表記を使用する： "'FOO" は "(QUOTE FOO)" と等価である。これは単なる表記上の便宜であり、この2つの表記は同じS式を表す。(S式は文字列ではなく、ある構造を持つデータ・オブジェクトである 。S 式を紙上で表記するには文字列を使用するが、小さなボックスや矢印など、他の表記法も使用できる。また、同じS式を複数の異なる文字列で表記することも可能である)。


## LISP 再帰方程式のインタープリター

これでLISPの進化の歴史を調べるのに十分な環境が整った。最初にLISP再帰方程式の完全なインタープリターを紹介する。解釈される言語はLISPの方言であり、基本または定義された手続き名以外の自由変数を許さず、他の手続き内の手続き定義も許さない。
ドライバ・ループは次のような手続き定義を読み取る： 

(DEFINE (F A B C ...) <A B C ..., F G H ...の式>) 

そして、それらを保存する。また、定義された手続きをいくつかの引数に適用する（あるいは、より一般的には、任意の式を評価する）要求を読み取ることもできます。式は、変数参照、定数（数値とクォートされたS式）、手続き呼び出し、条件式（COND）で構成される。定義された手続きは、互いに参照したり、最初に与えられた基本手続き（CAR、CONSなど）を参照したりすることができる。定義は、計算要求時に必要な定義がすべて存在する限り、「前方参照」を含むことが可能である。インタープリタそのものは、ここではそのような定義の集まりとして提示されているので、メタ循環インタプリタである。
この言語は適用順序で評価されることを意図している。つまり、手続きを引数に適用しようとする前に、手続きに対するすべての引数が完全に評価される。(これはメタ循環定義の形式には内在しないので、ここで明示的に述べる必要がある。この問題の説明は[Reynolds]を参照)。ドライバループ(図1参照)は、概念的には、引数なしでDRIVERを呼び出す要求によって開始される。そのタスクは、最初に "LITHP ITH LITHTENING "というメッセージ( ある種の伝統)をプリントし、次にDRIVER-LOOPを起動することである。<THE-PRIMITIVE-PROCEDURES>式は、DRIVER-LOOPに供給されるプリミティブ手続きの定義を含む定数リスト構造を表すことを意図している。

```lisp
(DEFINE (DRIVER)
        (DRIVER-LOOP <THE-PRIMITIVE-PROCEDURES> (PRINT '|LITHP TIH LITHTENING|)

(DEFINE (DRIVER-LOOP PROCEDURES HUNOZ)
        (DRIVER-LOOP1-PROCEDURES (READ)))

(DEFINE (DRIVER-LOOP-1 PROCEDURES FORM)
        (COND ((ATOM FORM)
               (DRIVER-LOOP PROCEDURES (PRNIT (EVAL FORM '() PROCEDURES))))
              ((EQ (CAR FORM) 'DEFINE)
               (DRIVER-LOOP (BIND (LIST (CAADR FORM)
                                  (LIST (LIST (CDADR FORM) (CADR FORM)))
                                  PROCEDURES)
                            (PRINT (CAADR FORM)))))
              (T (DRIVER-LOOP PROCEDURES (PRINT (EVAL FORM '() PROCEDURES))))))
Figure 1
再帰式インタープリタのトップレベル・ドライバ・ループ
```

DRIVER-LOOPは入力ストリームからS式を読み取り、それを現在の手続き定義とともにDRIVER-LOOP-1に渡す。この手続きは、入力されたS式が定義であるかどうかを判断する。もしそうであれば、BIND（後述）を使って手続き定義の拡張された集合を生成し、定義された手続きの名前を表示し、このプロセスを繰り返すためにDRIVER-LOOPを呼び出します。拡張された手続き集合はDRIVER-LOOPに渡されるため、変数PROCEDURESは常にこれまでに読み込まれたすべての累積された定義を含んでいる。入力されたS式が定義でない場合は、式の値を決定することを目的とする評価器EVALに渡される。{Note Value Quibble}。現在定義されている手続きの集合もEVALに渡される。
driver loopによって実行される処理は、しばしば "トップレベル "と呼ばれ、 すべてのユーザープログラムとリクエストは "その下 "で実行される。増え続ける手続き定義の集合は「トップレベル環境」と呼ばれる。この環境はユーザーとの対話の過程で変化し、ユーザーによって認識されるマシンの状態を含む。ユーザープログラムはこの環境の中で実行される。

```lisp
(DEFINE (EVAL EXP ENV PROCEDURES)
        (COND ((ATOM EXP)
               (COND ((EQ EXP 'NIL) 'NIL)
                     ((EQ EXP 'T) 'T)
                     ((NUMBERP EXP) EXP)
                     (T (VALUE EXP ENV))))
              ((EQ (CAR EXP) 'QUOTE)
               (CADR EXP))
              ((EQ (CAR EXP) 'COND)
               (EVCOND (CDR EXP) ENV PROCEDURES))
              (T (APPLY (VALUE (CAR EXP) PROCEDURES)
                        (EVLIS (CDR EXP) ENV PROCEDURES)
                        PROCEDURES))))

(DEFINE (APPLY FUN ARGS PROCEDURES)
        (COND ((PRIMOP FUN) (PRIMOP-APPLY FUN ARGS))
              (T (EVAL (CADR FUN)
                       (BIND (CAR FUN) ARGS '())
                       PROCEDURES))))

(DEFINE (ECOND CLAUSES ENV PROCEDURES)
        (COND ((NULL CLAUSES) (ERROR))
              ((EVAL (CAAR CLAUSES) ENV PROCEDURES)
               (EVAL (CADAR CLAUSES) ENV PROCEDURES))
              (T (EVCOND (CDR CLAUSES) ENV PROCEDURES))))

(DEFINE (EVLIS ARGLIST ENV PROCEDURES)
        (COND ((NULL ARGLIST) '())
              (T (CONS (EVAL (CAR ARGLIST) ENV PROCEDURES)
                       (EVLIS (CDR ARGLIST) ENV PROCEDURES)))))

Figure 2
再帰式インタープリタの評価器
```

評価システム（図2参照）は、2つの概念的な構成要素に分かれている： EVALとAPPLYである。EVALは式を分類し、その評価を指示する。単純な式（定数や変数など）は直接評価できる。複雑な手続き呼び出し（正確には "組み合わせ "と呼ばれる）の場合、EVALは手続き定義を検索し、（EVLISを使用して）引数を再帰的に評価し、次にAPPLYを呼び出す。APPLYは手続きを分類し、その実行を指示する。単純な手続き（プリミティブ演算子）は直接実行される。複雑なユーザー定義手続きの場合、APPLYはBINDを使用して環境を構築し、一種のシンボル・テーブルを作成し、手続き定義のフォーム・パラメーターとEVALが提供する実際の引数値を関連付ける。手続き定義の本体は、構築された環境とともにEVALに渡され、本体で発生する変数の値を決定するために使用される。
より詳細には、EVALはS式EXPの構造に関する場合分け分析である。アトムの場合、いくつかのサブケースがある。特別なアトムTとNILは、TとNILに評価されるように定義される（これは厳密には便宜的なもので、真理値として使用されるため）。同様に、数値アトムは便宜上、それ自身に対して評価される。(T、NIL、'43など、たくさんのQUOTEフォームを書くことをユーザーに要求することで、このようなケースをなくすことができる。しかし、アトム記号は変数をエンコードします。その記号に関連する値は、関数VALUE（下記参照）を使用して環境ENVから抽出されます。
評価される式がアトミックでない場合、QUOTE形式、COND形式、またはその組み合わせとなる。QUOTE フォームの場合、EVAL は CADR を使用して S 式定数を取り出します。述語が真の場合、EVCONDは（もちろんEVALを呼び出して）それに対応する結果式を評価する。述語が偽の場合、EVCONDはそれ自身を呼び出してCOND本体の次の節の述語をテストする。組み合わせの場合、手続きが取得され、引数が（EVLISを使用して）評価され、前述のようにAPPLYが呼び出される。VALUEは、PROCEDURES集合からプロシージャー定義を取得するために使用されることに注意してください。工学的なトリックとして、ENVとPROCEDURESが同じ構造を持つようにアレンジしているため、このようなことができます。
EVLISは単純な再帰関数で、ARGLISTの一連の引数に対してEVALを呼び出し、順番に値のリストを生成する。
APPLYはプリミティブとユーザー定義の2種類の手続きを区別する。今のところ、プリミティブ手続きに対してのみ真である述語PRIMOPと、そのようなプリミティブ手続きの適用を扱う関数PRIMOP-APPLYの存在を仮定することにより、プリミティブ手続きの正確な実装を記述することを避ける。(PRIMOPとPRIMOP-APPLYの可能な実装の詳細については{Note Primitive Operators}を参照のこと)。我々は  プリミティブ手続きは、数値や ATOMシンボル以外のアトムS式の一種であると考える。しかし、プリミティブ手続きは、その名前として使用されるアトム記号と混同してはならない。(VALUE 'CAR PROCEDURES)の結果はアトム記号CARではなく、PRIMOP-APPLYにのみ意味のある奇妙なオブジェクトである。
ユーザー定義手続きはここではリストとして表現される。これらのリストはDRIVER-LOOP-1によって構築される。リストのcarは正式なパラメータのリストであり、cadrは定義の本体である。


```lisp
(DEFINE (BIND VARS ARGS ENV)
        (COND ((= (LENGTH VARS) (LENGTH ARGS))
               (CONS (CONS VARS ARGS) ENV))
              (T (ERROR))))

(DEFINE (VALUE NAME ENV)
        (VALUE1 NAME (LOOKUP NAME ENV)))

(DEFINE (VALUE1 NAME SLOT)
        (COND ((EQ SLOT '&UNBOUND) (ERROR))
              (T (CAR SLOT))))

(DEFINE (LOOKUP NAME ENV)
        (COND ((NULL ENV) '&UNBOUND)
              (T (LOOKUP1 NAME (CAAR ENV) (CDAR ENV) ENV))))

(DEFINE (LOOKUP1 NAME VARS VALS ENV)
        (COND ((NULL VARS) (LOOKUP NAME (CDR ENV)))
              ((EQ NAME (CAR VARS)) VALS)
              (T (LOOKUP1 NAME (CDR VARS) (CDR VALS) ENV))))

Figure 3
環境を管理するユーティリティ・ルーチン
```

インタープリターはシンボル・テーブルを管理するために、いくつかのユーティリティ手続きを使用する（図3参照）。シンボル・テーブルは一連のバケット・リストとして表現される。各バケットは、carが名前のリスト、cdrが対応する値のリストであるリストである。{Note This ain't A-lists} ある変数名が複数のバケツに出現する場合、一番左のバケツが優先される。このようにして、リストの先頭に追加された新しいシンボル定義が古い定義に優先することができる。
BINDは名前のリスト、値のリスト、シンボルテーブルを受け取り、 古いシンボルテーブルに新しい組み合わせを含むバケットを追加した新しいシンボルテーブルを生成します。( これは便利なエラーチェックも行う。LENGTHはリストの長さを返す)。
VALUEは基本的にLOOKUPのインターフェースである。後述の第3部では、LOOKUPの基本的なアルゴリズムを変更することなく、異なるバージョンのVALUE1を使用することを想定しているため、VALUEを定義している。UNBOUNDのチェックは、未定義の変数に対する不正な参照を検出する。
LOOKUPは名前とシンボル・テーブルを受け取り、バケットのうちそのcarが関連する値である部分を返す。(この定義は、値そのものを返すものよりも後々役に立つだろう)。
インタプリタの変数PROCEDURESの使い方に注意してほしい。DRIVER-LOOP-1がEVALを呼び出すとき、現在定義されている手続き（プリミティブとユーザー定義の両方）のリストを渡す。DRIVER-LOOP-1はPROCEDURESの値を増大させる唯一のルーチンで、EVALではこの値がVALUEに渡された時のみ使用されます。しかし、APPLY、EVCOND、EVLISの全てのルーチンはPROCEDURESについて知らなければならず、最終的にEVALで使用されるように、それをきちんと渡さなければならない。自由変数や副作用の規定がないため、定義のセットは渡されなければならない。渡された変数以外に「メモリー」や「状態」を持つ方法はない。自由変数がないため、言語は参照的に透明である。しかし、PROCEDURESの使い方にはモジュール性の欠如を感じる（また、EVCONDやEVLISのENVの使い方にもモジュール性の欠如を感じる）。この点については後で触れる。
この再帰式言語は、Algolのfor文やFORTRANのDOループのような特別な反復やループの構成要素を持たない。すべてのループは、再帰プロシージャが自分自身またはお互いを呼び出すように配置することによって構築される。例えば、EVCOND（図2参照）は、CONDの節のリストの連続する「末尾」で自分自身を呼び出すことによって、CONDの節を繰り返し処理する。このような再帰的な呼び出しは、他の言語（Algol、FORTRAN、PL/Iなど）に慣れ親しんだ読者にとっては、実際のプログラムを実装する上で非効率的であると直感的に感じるかもしれない。たとえ呼び出しが高速に行われるとしても、リターン・アドレスやその他の制御情報の形で空間を消費するように思われる。しかし、再帰式評価器を調べれば、このような現象が起こる必要がないことがわかる。なぜなら、再帰呼び出しから戻ったときに何もすることがなければ、余分な情報は保存されないからである。これに関するより詳細な議論は、[SCHEME]と[Debunking]を参照のこと。


# 第1部 - 変数スコープの規律

## データとしての手続き

第0部で説明したシンプルなLISPは、記号数学のアルゴリズムを含む、かなり複雑なアルゴリズムを記号化するための快適な媒体となり得る。多項式の係数の集合や空間ベクトルの座標のような構造を表現するために、しばしばリストが使われる。多くの問題では、リストの各要素に対して演算を行い、その結果の新しいリストを生成する必要がある。例えば、あるベクトルの各要素の2乗のリストを作るのが便利であろう。これを次のように書く： 

(DEFINE (SQUARELIST L)
        (COND ((NULL L) '())
              (T (CONS (SQUARE (CAR L))
                       (SQUARELIST (CDR L))))))

私たちはこのパターンを何度も書いていることに気づく：


(DEFINE (fLIST L)
        (COND ((NULL L) '())
              (T (CONS (f (CAR L))
                       (fLIST (CDR L))))))

ここでfはリストの要素に対して定義された関数である。この抽象的なパターンを捕らえるプログラミング言語の実体を定義できればいいのだが、それは難しい。「明らかな」解決策は、引数として受け取ることができる関数型の変数として変数関数を書くことである： 

(DEFINE (MAPCAR F L)
        (COND ((NULL L) '())
              (T (CONS (F (CAR L))
                 (MAPCAR F (CDR L))))))

(MAPCARはこの抽象化の伝統的な名称である）これを用いて我々はこう言うことができる： 

(MAPCAR SQUARE (1 2 3)) 

残念ながら、これは再帰方程式のインタープリターでは機能しない。なぜか？
問題の本質は、インタープリターが手続きを他の種類のオブジェクトと区別していることにある。我々はFを手続きと呼んでいるが、これは変数として渡されたものである。手続きはPROCEDURESシンボル・テーブルでしか検索されないが、変数はENVで束縛される。さらに、MAPCARの呼び出しではSQUAREが変数として使用されており、これはENVで検索されるが、その定義はPROCEDURESでしか利用できない。
2つのシンボル・テーブルをマージしてみよう。どうだろう？

```lisp
(DEFINE (DRIVER-LOOP-1 ENV FORM)
        (COND ((ATOM FORM)
               (DRIVER-LOOP ENV (PRINT (EVAL FORM ENV))))
              ((EQ (CAR FORM) 'DEFINE)
               (DRIVER-LOOP (BIND (LIST (CAADR FORM))
                                  (LIST (LIST '&PROCEDURE (CDADR FORM) (CADDR FORM)))
                                  ENV)
                            (PRINT (CAADR FORM))))
              (T (DRIVER-LOOP ENV (PRINT (EVAL FORM ENV))))))

For DRIVER-LOOP see Figure 1.
For EVAL see Figure 5.
For BIND see Figure 3.

Figure 4
手続きをオブジェクトとして扱うためのドライバ・ループの修正
```

今後はPROCEDURESを省き、ENVを手続きとその他のオブジェクトの両方に使用する。ドライバー・ループは、EVALの呼び出しで引数 () をなくす以外は、特に変更する必要はない（図4参照）。また、PROCEDURESという名前もENVに変更するが、もちろん論理的には必要ない。(((((；ﾟДﾟ))))))) {Note EVALQUOTE} 。
(手続きオブジェクトにフラグを立てるために使うおかしなオブジェクト&PROCEDUREを導入しました。以前のインタプリタでは、プリミティブ演算子でもDEFINEフォームで生成された手続きでもないオブジェクトの実行をユーザが要求することは不可能でした。手続きが他のデータオブジェクトと自由に混在するようになった現在では、例えばAPPLYでのエラーチェックのために、それらを区別できるようにすることが望ましい。また、手続きとそのテキスト表現との混同を避けるという深い動機もあるが、この問題はまだ扱いたくない)。
評価器を修正するために、PROCEDURESをすべて取り除きます。EVALでは、組み合わせの手続き名が検索されますが、ENVで検索するように変更します。最後に、APPLYに問題がある：本体を評価するためのEVALへの呼び出しが単に 

(EVAL (CADDR FUN)
      (BIND (CADR FUN) ARGS '()))

この場合、EVALに与えられた新しいENVには手続き定義がない。さらに、APPLYは手続き定義を含む環境にアクセスすることさえできない（パラメータPROCEDURESが削除されたため）！これは簡単に修正できる。APPLYがEVALから呼び出されるとき、ENVは（PROCEDURESがそうであったように）一緒に渡すことができ、APPLYからEVALへの呼び出しは次のように変更できます。

(EVAL (CADDR FUN)
      (BIND (CADR FUN) ARGS ENV))

このようにして、EVALに渡される環境は、手続き定義を含む古い環境に追加された新しい変数束縛を含むことになる。(図5参照。) これは実に良い特徴である：定義された手続きの名前がローカル変数(手続き変数であろうとなかろうと)として使われる場合、新しい束縛がローカルで優先され、一時的にグローバル定義に取って代わられる。

```lisp
(DEFINE (EVAL EXP ENV)
        (COND ((ATOM EXP)
               (COND ((NUMBERP EXP) EXP)
                     (T (VALUE EXP ENV)))) 
              ((EQ (CAR EXP) 'QUOTE)
               (CADR EXP))
              ((EQ (CAR EXP) 'COND)
               (EVCOND (CDR EXP) ENV))
              (T (APPLY (VALUE (CAR EXP) ENV)
                        (EVLIS (CDR EXP) ENV)
                        ENV))))

(DEFINE (APPLY FUN ARGS ENV)
        (COND ((PRIMOP FUN) (PRIMOP-APPLY FUN ARGS))
              ((EQ (CAR FUN) '&PROCEDURE)
               (EVAL (CADDR FUN)
                     (BIND (CADR FUN) ARGS ENV)))
              (T (ERROR))))

(DEFINE (ECOND CLAUSES ENV)
        (COND ((NULL CLAUSES) (ERROR))
              ((EVAL (CAAR CLAUSES) ENV)
               (EVAL (CADAR CLAUSES) ENV))
              (T (EVCOND (CDR CLAUSES) ENV))))

(DEFINE (EVLIS ARGLIST ENV)
        (COND ((NULL ARGLIST) '())
              (T (CONS (EVAL (CAR ARGLIST) ENV)
                       (EVLIS (CDR ARGLIST) ENV)))))

For VALUE and BIND see Figure 3.

Figure 5
手続きをオブジェクトとして扱うための評価器
```

このバージョンのインタープリターのもう一つの良い点は、PROCEDURESの不規則な出現がなくなったことだ。もちろん、この問題が解決されたわけではないが、このような特殊な状況が解消されたことは確かである！
ところで、DRIVERが提供する初期環境にそれらの初期値を置くだけでよいとして、EVALにおける1とNILの明示的なテストも廃止した。
このインタプリタの興味深い特性は、自由変数に意味が与えられたことである。実際、元の再帰式インタープリタでは、ある意味で自由変数が存在した。すべての手続き変数は自由であった（ただし、組み合わせの演算子の位置でのみ使用可能であった）。私たちの新しいインタープリターでは、手続き変数と変数環境が統合されたおかげで、拘束された手続き名だけでなく、自由な変数名も持つことができる。
このインタープリタは、LISP 1.5[LISP1.5M]のインタープリタとは細かい点でしか違いがない。どちらも動的にスコープされる自由変数を持っています（この点については後で詳しく説明します）。APPLYの第1引数を演算するときにEVALのVALUEへの参照をEVALへの参照に置き換えることができることに注意する必要があります；これは、変数が組み合わせの演算子の位置に現れる場合に同じことを行い、手続きを計算するために任意の式を使用する追加の一般的な機能を可能にします。この違いは実際にLISP 1.5インタプリタに現れている。その他にも、プリミティブな演算子の表現や、プリミティブでもユーザー定義でもない手続きの扱いなど、わずかな違いがあります。これらを除けば、我々のインタプリタとLISP 1.5のインタプリタとの最大の違いは、ラムダ記法の使用です。これは次のセクションで説明する。


## ローカル手続き

これでMAPCAR手続きを定義し、使用することができるようになった。しかし、もう少しプログラミングを経験すると、ループから共通パターンを抽象化した後、残りの部分（関数型引数）がMAPCARの呼び出しごとに異なる傾向があることに気づきます。残念なことに、私たちの言語では機能的引数を参照するために名前を使わなければならない。些細な手続きに対してユニークな名前を考えるのはすぐに飽きてしまう：

(DEFINE (FOOBAR-43 X) (* (+ X 4) 3))

... (MAPCAR FOOBAR-43 L)

私たちは名前の衝突のリスクを負うことになる。また、手続き定義を使用する1つのポイントで記述できるのは良いことだ。
もっと抽象的に言えば、手続きは言語内で参照可能なオブジェクトになったのだから、オブジェクトとしての手続きの記法があってもいいだろう。LISP [LISP 1M]は、このような表記法をAlonzo Church [Church]のλ-calculusから採用した：

(LAMBDA <variables> <body>)

これをDEFINE記法と比較すると、同じ部分を持っていることがわかる：認識できるキーワード、パラメータのリスト、本体。唯一の違いは、無関係な名前が省略されていることである。ただそれだけである。
このように考えると、次のように書くことができる。 

(MAPCAR (LAMBDA (X) (* X X)) L) 

SQUAREを別の手続きとして定義する必要はありません。さらに、この表記法の利点は、関連するコードがすべてローカルに存在するため、コンパイラがこのコードを調べ、効率的な反復実装を生成するのが非常に簡単になることです（コンパイラはMAPCARを知っていると仮定します）。
この表記法をインストールするには、EVALを2行変更するだけでよい（図6参照）。

```lisp
(DEFINE (EVAL EXP ENV)
        (COND ((ATOM EXP)
               (COND ((NUMBERP EXP) EXP)
                     (T (VALUE EXP ENV))))
              ((EQ (CAR EXP) 'QUOTE)
               (CADR EXP))
              ((EQ (CAR EXP) 'COND)
               (EVCOND (CDR EXP) ENV))
              ((EQ (CAR EXP) 'LAMBDA)
               (CONS '&PROCEDURE (CDR EXP)))
              (T (APPLY (EVAL (CAR EXP) ENV)
                        (EVLIS (CDR EXP) ENV)
                        ENV))))

For VALUE see Figure 3.
For APPLY, EVCOND, and EvLIs see Figure 5.

Figure 6
LAMBDA-notationの評価器（動的にスコープされる）
```

( 読み手はLAMBDA式に対してEVALがすることはLAMBDAという単語を&PROCEDUREという単語に置き換えるだけであり、手続きオブジェクトのフラグとして&PROCEDUREの代わりにLAMBDAを統一的に使用することでその作業を回避できることに気づいたかもしれない。LAMBDA式のEVALはidentity操作であることを考えると、ユーザに(LAMBDA ...)の代わりに'(LAMBDA ...)と書かせるだけで、EVALにおけるLAMBDAの取り扱いをなくすことができます。ほとんどのLISPの実装者は、LISP1以来、実際にこのようにしてきましたが、これは非常に悪い考えです。EVALは式を処理してその値を生成するものであり、それが恒等式演算として実装されるかもしれないという事実は、ユーザには関係ありません。手続きオブジェクトと、そのオブジェクトを値として持つ式との混同は、深刻な問題を引き起こします。(15と(+78)を混同して、後者の代わりに前者のcarを取ろうとしたり、前者の代わりに後者に3を足そうとすることを想像してみてください!) 上記で述べたクオートされたLAMBDA式工学のトリックは参照透過的なLISPの実装を妨げるものである。第4部では、参照透過性をあからさまに破壊することによって、LISPコンパイラ（あるいは他のプログラム理解者）にとって非常に困難なことが起こることを説明します。{Note QUOTE Shafts the Compiler}) 
自由変数とローカル手続きを使えるようになったことで、興味深い手続きを表現する自由度が増した。例えば、任意の長さのベクトルにスカラーを掛ける手続きSCALEを定義することができる。ベクトルが成分のリストとして表現されるなら、MAPCARと自由変数を使ったローカル手続きが使えます： 

(DEFINE (SCALE S V)
        (MAPCAR (LAMBDA (X) (* X S))
                V))

ある小さな不具合を除けば、すべてが順調だ。SCALEを書いたプログラマーが、何らかの理由でスケールを表すのにSではなくLを選んだとしよう： 

(DEFINE (SCALE L V) 
        (MAPCAR (LAMBDA (X) (* X L))
                V))

sを使ったバージョンは機能するが、Lを使ったバージョンは機能しない。これは MAPCAR が引数の名前（つまり "ローカル "変数）を使用しているために起こります。SCALE の LAMBDA 式の中の L への参照は MAPCAR で束縛された L を指し、SCALE で束縛された L を指しません。一般に、ある手続きにおける自由変数への参照は、呼び出しの連鎖の上位にある他の手続きにおける変数の束縛を参照します。変数の束縛と参照は動的に確立され、異なる手続きが実行されるたびに変化するため、この規則は変数の動的スコープと呼ばれます。
SCALEプログラムの動作がローカル変数の名前の選択に依存することは、参照透明性の違反です。MAPCAR の抽象化のモジュール性は破壊されている。なぜなら、誰もその実装の詳細を理解することなく、その抽象化を使用することはできないからである。これが有名な "FUNARG問題" [Moses] [LISP History]である。
同じ名前の異なる使い方の間でこのような衝突が起こらないようにするには、ローカルでの名前の選択がグローバルな影響を及ぼさないように言語をアレンジする必要があります。より具体的には、変数が真にローカルな意味を持つように束縛する機能が必要です（一般的には、すべての変数が厳密にローカルである必要はないかもしれませんが、いくつかのタイプの変数を持つ可能性については後で検討します）。


## レキシカル・スコープ

ここで、すべての変数が厳密にローカルな使い方をするインタプリタを構築する。これは変数のレキシカル・スコープと呼ばれ、Algol 60 [Naur]を含む多くのプログラミング言語で採用されている。この「レキシカル（lexical）」という用語は、ローカル変数束縛へのすべての参照がプログラム内で明示されることを意味する。静的束縛という用語も使われますが、これは束縛と参照の間の接続が実行時に不変であることを示します。
SCALEで難しいのは、LAMBDA式の本体(* X L)が、MAPCARの本体を処理するときにEVALが使用可能であった（そしてAPPLYに渡された）ENVを使用して評価されることである。しかし、我々は(* X L)をSCALE本体が評価されているときに使用可能だったENVを使用して評価したい。何らかの方法で、この環境が(* X L)を評価するために利用できるように手配しなければならない。
正しい環境はLAMBDA式が&PROCEDURE-オブジェクトを生成するために評価されたときに利用可能でした。なぜその時点の環境を&PROCEDURE-objectの末尾に付加して、手続きが適用されたときに使用できるようにしないのでしょうか？
実際、これは正しいことだ。MAPCARに与えたいオブジェクトは、実行される計算を記述したテキストだけでなく、そのテキストで参照される自由変数の意味も含んでいなければならない。この2つの組み合わせだけが、マッピングされる抽象関数の完全な意味を反映した計算を正しく指定することができるのです。ここで初めて、3つの考え方を区別することが重要であることがわかる： (1)プログラム、つまりS式の形式などで手続きを記述したテキスト、(2)コンピュータによって実行される手続き、(3)手続きの実行によって計算される数学的関数やその他の概念的演算。
インタプリタにレキシカル・スコープを導入するには、EVALのLAMBDA式の扱いを変更し、現在の環境ENVを&PROCEDURE-オブジェクトの一部としなければならない。現在の環境では手続きは閉じられており、&PROCEDURE-オブジェクトは手続きのクロージャ、または閉じられた手続きと呼ばれます。また、APPLYを変更して、新しい変数と値の関連付けを、EVALで渡される環境ではなく、&PROCEDURE-オブジェクトの環境にバインドするようにしなければならない。APPLYの定義からパラメータENVを削除し、EVALで発生するAPPLYの呼び出しを変更する。このように、LAMBDA式の取り扱いは複雑になったが、ENVの取り扱いはそれに応じて単純化された。(図7参照）。
前節で説明したようなトリックを採用していた場合、ユーザーは'(LAMBDA式)と書く必要があった。
動的スコープからレキシカル・スコープへの変更はプログラミング・スタイルの大幅な変更を伴うものであり、これが動的スコープが歴史的に標準的な規律となった後、クォートの問題が解決されなかった理由であることは間違いない。動的スコープがモジュール性を生み出す貴重な技法であることは後述するが、クォートされたLAMBDA式が生み出す混乱には何の美徳もない。クォートされたLAMBDA式は動的スコープを生成するが、動的スコープのサポートはLAMBDA式のクォートには依存しない)。
レキシカル・スコープは参照透明性の問題を解決してくれますが、その代償として大きな代償を支払わなければならないことが後でわかります！

```lisp
(DEFINE (EVAL EXP ENV)
        (COND ((ATOM EXP)
               (COND ((NUMBERP EXP) EXP)
                     (T (VALUE EXP ENV))))
              ((EQ (CAR EXP) 'QUOTE)
               (CADR EXP))
              ((EQ (CAR EXP) 'LAMBDA)
               (LIST '&PROCEDURE (CADR EXP) (CADDR EXP) ENV))
              ((EQ (CAR EXP) 'COND)
               (EVCOND (CDR EXP) ENV))
              (T (APPLY (EVAL (CAR EXP) ENV)
                        (EVLIS (CDR EXP) ENV)))))

(DEFINE (APPLY FUN ARGS)
        (COND ((PRIMOP FUN) (PRIMOP-APPLY FUN ARGS))
              ((EQ (CAR FUN) '&PROCEDURE)
               (EVAL (CADDR FUN)
                     (BIND (CADR FUN) ARGS (CADDDR FUN))))
              (T (ERROR))))

For VALUE and BNID see Figure 3.
For EVCOND and EVLIS see Figure 5.

Figure 7
レキシカル・スコープ付きLAMBDA-notationの評価器
```

何を買ったか見てみよう。ひとつはMAPCARを一般化することだ。さらにプログラミングの経験を積むと、MAPCARのような手続きをたくさん書くことに気づく。例えば、関数Fが常にリストを返すような種類のMAPCARが必要で、リストのリストではなく、リストの連なりを作りたいかもしれない。また、リスト内のすべての数値の和や積、あるいはリスト内のすべての要素のcarの和を取りたい場合もある。一般的なパターンは、リストの各要素を見て、それに対して何かを行い、そしてこれらの要素ごとの演算結果を何らかの方法で結合する、というものだ。他の応用例としては、リスト内の重複をチェックすることがある；各要素について、リスト内で別のコピーがそれに続いているかどうかを調べたい。さらに、このパターンを一般化して、リストの末尾の部分を調べることもできる；1つの要素を得るために、いつでもcarを取ることができる。
MAPCARに手続きパラメーターを追加するだけでよい： 

(DEFINE (MAP F OP ID L)
        (COND ((NULL L) ID)
              (T (OP (F L)
                     (MAP F OP ID (CDR L))))))

これを使えば、リストLのコピーを作ることができる： 

(MAP CAR CONS '() L)

つまり、(MAPCAR F L)をシミュレートすることができる： 

(MAP (LAMBDA (X) (F (CAR X))) CONS '() L)

確かに、私たちはこう書くことができる：

(DEFINE (MAPCAR F L) 
        (MAP (LAMBDA (X) (F (CAR X))) CONS '() L))

Lの要素を合計することができる：

(MAP CAR + 0 L) 

Lの要素の積を取ることができる： 

(MAP CAR * 1 L) 

Lの重複要素の組を数えることができる： 

(MAP (LAMBDA (X) X)
     (LAMBDA (Y N) (COND ((MEMBER (CAR Y) (CDR Y))
                          (+ N 1))
                         (T N)))
     0
     L)

異なる場所にあるたくさんのリストの和を取る機会がある場合、"sum over list "という演算をパッケージ化したいと思うかもしれない-"CAR + 0 "と書くのは非常に疲れるのだ。

(DEFINE (MAPGEN F OP ID)
        (LAMBDA (L) (MAP F OP ID L)))

(MAPGEN CAR + 0)の結果をSUMと呼ぶかもしれない。これはリストの要素を合計する引数1つの手続きである。SUMを作る手続きを書いたのは、単にこう書くからではない：

(DEFINE (SUM L)
        (MAP CAR + 0 L))

MAPGENは、このような手続きの一般化された構成子として機能するため、興味深い抽象化が可能になる-たとえば、（MAPGEN CAR * 1）の結果をPRODUCTと呼ぶなど。
これが面白いのは、他の手続きを構築する手続きを書くことができるということだ。これは手続きのS式表現を構築する能力と混同してはならない。手続きを構築する機能は、動的にスコープされたインタープリターでは利用できなかった。参照透明性の違反を解決することで、私たちはさらなる抽象化能力の源に出くわしたようだ。MAPの例は窮屈に見えるかもしれないが、この例はごく自然なものである：数値関数が与えられたとき、最初の関数の微分を数値的に近似する新しい関数を生成する。

(DEFINE (DERIVATIVE F ΔX) 
        (LAMBDA (X)
                (/ (- (F (+ X ΔX))
                      (F X))
                   ΔX)))

DERIVATIVE手続きはFの内部構造については何も知らないし、Fを呼び出すことによってのみFを使用する新しい手続きを構築するだけである、ということに注意してほしい。DERIVATIVEプログラムは、（近似的に）「微分」の抽象化を、数値的な（そして適度にお行儀のよい！）関数の空間からそれ自身への写像として捉えている。
他の手続きを構築する手続きを定義する機能は強力である。これを使えば、データオブジェクトのように振る舞う手続きを構築することができる。例えば、CONSが（今のところ）従わなければならない制約は代数的恒等式だけである：

(CAR (CONS α β)) = α and (CDR (CONS α β)) = β

(CONS α β)の値は、要求に応じてaまたはβを生成する手続きと考えることができる（[Hewitt and Smith] [Fischer]を参照）。これを次のように書くことができる：

(DEFINE (CONS A D) 
        (LAMBDA (M) 
                (COND ((= M 0) A)
                      ((= M 1) D))))

(DEFINE (CAR X) (X 0)) 

(DEFINE (CDR X) (X 1)) 

ここでは、(CONS α β)の値を2つの要素からなるベクトルとし、ゼロを原点とするインデックスを付けることを想定している。しかし、このCONSの定義では、プリミティブ演算子=を使用している。他のプリミティブ演算子を全く使用せずに、「プリミティブ演算子」CONS、CAR、CDRを定義することができる！[Church]に従い、こう書く：

(DEFINE (CONS A D) 
        (LAMBDA (M) (M A D)))

(DEFINE (CAR X)
        (X (LAMBDA (A D) A)))

(DEFINE (CDR X)
        (X (LAMBDA (A D) D)))

セレクタとして0と1（すなわちデータオブジェクト）を使うのではなく、代わりに(LAMBDA (A D) A)と(LAMBDA (A D) D)（すなわち手続き）を使う。
DERIVATIVEまたはCONSの定義の本体として現れるLAMBDA式は、新しい手続きの原型と考えることができます。DERIVATIVEやCONSが呼び出されると、この原型はクロージャとしてインスタンス化され、原型の自由変数はコンストラクタに与えられた引数に束縛されます。
この時点で、すべての問題は解決したように見える。我々は、参照透過だが表現力の弱い言語から始めた。それを手続き型オブジェクトとその記法で補強し、抽象化とモジュール化の概念を取り入れた。その際、参照透過性を失ってしまった。そしてその過程で、さらに強力な抽象化機能を発見したのである。



## トップレベル対参照透明性

「情熱力学の三法則」： 
1. 勝てない。
2. 収支を合わせることはできない。
3. 試合から抜け出せない。" 
- 不明

フリーランチなどない。我々は、トップレベルのドライバー・ループに必要な変更を無視してきた。我々は&PROCEDURE-オブジェクトのフォーマットを変更した。DRIVER-LOOP-1は&PROCEDURE-オブジェクトを構築する；変更に対応するために書き直さなければならない。そのようなオブジェクトのそれぞれに環境を含めなければならない。明らかな修正を図8に示す。

```lisp
(DEFINE (DRIVER-LOOP-1 ENV FORM)
        (COND ((ATOM FORM)
               (DRIVER-LOOP ENV (PRINT (EVAL FORM ENV))))
              ((EQ (CAR FORM) 'DEFINE)
               (DRIVER-LOOP (BIND (LIST (CAADR FORM))
                                  (LIST (LIST '&PROCEDURE
                                              (CDADR FORM)
                                              (CADDR FORM)
                                              ENV))
                                  ENV)
                            (PRINT (CAADR FORM))))
              (T (DRIVER-LOOP ENV (PRNIT (EVAL FORM ENV))))))

For DRIVER-LOOP see Figure 1.
For BIND see Figure 3.
For EVAL see Figure 7.

Figure 8
レキシカルにスコープされたLAMBDA-notationのための修正されたドライバーループ
```

It doesn't work. This patch does put the finishing touch on the preservation of referential transparency. It does it so well, that each new definition can only refer to previously defined names! We have lost the ability to make forward references. We can't redefine a procedure which had a bug in it and expect old references to use the new definition. In fact, we cannot use DEFINE to make a recursive procedure. {Note Y-operator} The &PROCEDURE -object for each defined procedure contains environment having only the previously defined procedures.
We are finally confronted with the fact that we have been seeking the impossible. We have tried to attain complete referential transparency (in the expectation that modularity would be enhanced), while trying also to retain the notion of an incremental, interactive top-level loop for reading definitions. But the very existence of such a top level inherently constitutes a violation of referential transparency. A piece of code can be read in which refers to an as yet undefined identifier (the name of a procedure, for example), and then later a definition for that identifier read in (thereby altering the meaning of the reference).
If we stubbornly insist on maintaining absolute referential transparency in our language, we are forced to eliminate the incremental top level loop. A program must be constructed monolithically. We must read in all our procedure definitions at once, close them all together, and then take one or more shots at running them. (This is the way many Algol implementations work; development of large systems can be very difficult if parts cannot be separately constructed and compiled.) We are forced to give up interactive debugging, because we cannot redefine erroneous procedures easily. We are forced to give up incremental compilation of separate modules.
We have thrown the baby out with the bath water. The very purpose of referential transparency is to permit programs to be divided into parts so that each part can be separately specified without a description of its implementation. The desirable result is that pieces can be separately written and debugged. {Note Debugging}
On the other hand, if we give up absolute referential transparency, we can fix the top level loop. The basic problem is that we really want procedures defined at top level to be able to refer to procedures defined later. The problem with pure lexical scoping is that the &PROCEDURE-objects are created too early, when the desired environment is not yet available. We must arrange for them to be constructed at a later time. We could simply use the environment in use by the caller at the time of invocation (reverting to dynamic scoping). But dynamic scoping would lose a great deal of referential transparency and abstractive power. Procedures must not be allowed to refer to variables internal to other procedures, but only to top-level variables existing at the time they are called. Therefore only the future top-level environment is to be included in the &PROCEDURE-object when it is eventually constructed. In this way free variable references will be dynamic only with respect to the top-level environment.
Considering our dynamically-scoped interpreter above (see Figure 5), we would be led to modify APPLY again, to combine the best properties of the dynamically and lexically scoped interpreters. Indeed, the two kinds of function can easily coexist. We borrow the code involving the passing of PROCEDURES (including the DRIVER-LOOP, modified to initialize ENV to PROCEDURES) from the recursion-equations interpreter (Figures 1 and 2), the code for using this top-level environment from the dynamically-scoped interpreter (Figure 5), and the code for constructing &PROCEDURE-Objects for LAMBDA-expressions from the lexically-scoped interpreter (Figure 7). The result appears in Figure 9.

```lisp
(DEFINE (EVAL EXP ENV PROCEDURES)
        (COND ((ATOM EXP)
               (COND ((NUMBERP EXP) EXP)
                     (T (VALUE EXP ENV))))
              ((EQ (CAR EXP) 'QUOTE)
               (CADR EXP))
              ((EQ (CAR EXP) 'LAMBDA)
               (LIST '&PROCEDURE (CADR EXP) (CADDR EXP) ENV))
              ((EQ (CAR EXP) 'COND)
               (EVCOND (CDR EXP) ENV PROCEDURES))
              (T (APPLY (EVAL (CAR EXP) ENV PROCEDURES)
                        (EVLIS (CDR EXP) ENV PROCEDURES)
                        PROCEDURES))))

(DEFINE (APPLY FUN ARGS PROCEDURES)
        (COND ((PRIMOP FUN) (PRIMOP-APPLY FUN ARGS))
              ((EQ (CAR FUN) '&PROCEDURE)
               (EVAL (CADDR FUN)
                     (BIND (CADR FUN) ARGS (CADDDR FUN)
                     PROCEDURES)))
              (T (EVAL (CADR FUN)
                       (BIND (CAR FUN) ARGS PROCEDURES)
                       PROCEDURES))))

(DEFINE (DRIVER-LOOP-1 PROCEDURES FORM)
        (COND ((ATOM FORM)
               (DRIVER-LOOP PROCEDURES
                            (PRINT (EVAL FORM PROCEDURES PROCEDURES))))
              ((EQ (CAR FORM) 'DEFINE)
               (DRIVER-LOOP (BIND (LIST (CAADR FORM))
                                  (LIST (LIST (CDADR FORM) (CADDR FORM)))
                                  PROCEDURES)
                            (PRINT (CAADR FORM))))
              (T (DRIVER-LOOP PROCEDURES
                              (PRINT (EVAL FORM PROCEDURES PROCEDURES))))))

For DRIVER-LOOP See Figure 1.
For VALUE and BNID see Figure 3.
For EvCOND and EvLIs see Figure .2

Figure 9
An Evaluator for Local Lexical Scoping and Dynamic Top-Level References
```

Ugh bletch, PROCEDURES is back! Also, there are two kinds of user-defined procedural objects floating around. There happens to be another way to fix the top level, which yields additional flavor. We note that during any one processing cycle of EVAL/APPLY, PROCEDURES remains constant. We can thus choose to associate the top level environment with a top-level procedure at a a time earlier than invocation time in APPLY. We also note that LOOKUP1 will have its hands on the top-level environment anyway just before it locates the definition of a top-level procedure. Exploiting this idea yields an alternate solution. {Note LABELS} 
In the new driver (see Figure 10) loop we no longer use BIND to augment the top-level environment whenever a new definition is made. instead have all of the top-level definitions in one frame of the environment. When a new definition is to be made we extract the list of names and the list of values for the old definitions from the old environment and make a new top-level environment with the lists of names and values separately augmented.
Instead of creating & PROCEDURE -objects, this driver loop creates &LABELED-objects, which have the same format except that they contain no environment. A &LABELED-object is purely internal and can never be seen by a user program. When LOOKUP1 encounters such an object as the value of a variable, it immediately creates the corresponding &PROCEDURE -object, using the environment at hand, which turns out to be the top-level environment.


```lisp
(DEFINE (DRIVER-LOOP-1 ENV FORM)
        (COND ((ATOM FORM)
               (DRIVER-LOOP ENV (PRINT (EVAL FORM ENV))))
              ((EQ (CAR FORM) 'DEFINE)
               (DRIVER-LOOP (LIST (CONS (CONS (CAADR FORM) (CAAR ENV))
                                        (CONS (LIST '&LABELED
                                                    (CDADR FORM)
                                                    (CADDR FORM))
                                              (CDAR ENV))))
                            (PRINT (CAADR FORM))))
              (T (DRIVER-LOOP ENV (PRINT (EVAL FORM ENV))))))

(DEFINE (LOOKUP1 NAME VARS VALS ENV)
        (COND ((NULL VARS)
               (LOOKUP NAME (CDR ENV)))
              ((EQ NAME (CAR VARS))
               (COND ((ATOM (CAR VALS)) VALS)
                     ((EQ (CAAR VALS) '&LABELED)
                      (LIST '&PROCEDURE (CADAR VALS) (CADDAR VALS) ENV))
                     (T VALS)))
              (T (LOOKUP1 NAME (CDR VARS) (CDR VALS) ENV))))

For DRIVER-LOOP see Figure 1.
For LOOKUP see Figure 3.
For EVAL see Figure 7.

Figure 10
An Alternative Solution for Local Lexical Scoping and Dynamic Top-Level References
(Modified Top-Level Driver Loop and Environment Lookup)
```


# Part Two - State

## Decomposition of State

We saw in Part One that an interactive top-level loop necessarily violates referential transparency. We wish to deal with the computer as an entity with state, which changes over time by interacting with a user. In particular, we want the computer to change over time by accumulating procedure definitions.
Just as the user wishes to think of the computer as having state, he may find it conceptually convenient to organize a program similarly: one part may deal with another part having state. Often programs are written for the purpose of analyzing or simulating a physical system. If modules of the program are to reflect the conceptual divisions of the physical system, then the program modules may well need to have independent state variables. Thus the notion of state is not just a programming trick, but may be required by the nature of the problem domain.
A simpler example of the use of state involves the use of a pseudo-random number generator. A LISP version of one might be:

(DEFINE (RANDOM SEED) 
        ((LAMBDA (Z) 
                 (COND ((> Z 0) Z)
                       (T (+ Z -32768.))))
         (* SEED 899.)))

This version of 'RANDOM uses the power-residue method for a 16-bit two's-complement number representation; the value produced is a pseudo-random integer, and also is the seed for the next call. The caller of RANDOM is required to save this value and supply it on the next call to RANDOM.
This fact is unfortunate. The caller really has no interest in the workings of RANDOM, and would much prefer to simply call it as "(RANDOM)", for example, and get back a random number - because this would reflect most precisely the abstract notion of "random number generator". Such a generator would have to have state.
Suppose we are willing to live with this nuisance. Consider now building some larger program using RANDOM. Many levels up, the programmer who writes some high-level routine. very likely does not care at all that a low-level routine uses RANDOM; he may not even know about the existence of that routine. However, if the state of the pseudo-random number generator is to be preserved, that programmer will have to deal with some state quantity he knows nothing about, for the sake of a program ten levels removed from his thinking. Just as PROCEDURES had to be passed all around for the sake of EVAL in Figure 2, so the state of RANDOM must be passed up and down and all around by programs which don't really care. This clearly violates our principle of modularity. (For an example of how bad this can get, see {Note Gaussian}.)
As another example, suppose that George writes MAPCAR, and Harry uses it. Harry complains that MAPCAR is too slow. George then decides to collect some statistics about the use of MAPCAR, such as the number of times called, the average length of the second argument, and so on. He first writes an experimental MAPCAR to count number of calls:

(DEFINE (MAPCAR F L N) 
        (CONS (OLDMAPCAR F L) (+ N 1)))

(DEFINE (OLDMAPCAR F L)
        (COND ((NULL L) '())
              (T (CONS (F (CAR L))
                       (OLDMAPCAR F (CDR L))))))

and asks Harry to use it for a while in his program. "I had to add an extra argument to keep track of the count,' says George, "and in order to return both the result and the count, I had to cons them together. Please rewrite your program to keep track of the count and pass it on from one call on MAPCAR to the next." Harry's reply is "unprintable".
Now Bruce comes along and asks Harry how to use Harry's program. Harry says, "Just write (DIFFERENTIATE EXP VAR N), where EXP is the expression to be differentiated, VAR is the variable with respect to which to differentiate, and N is George's statistics counter - but that may go away next week." Bruce gives Harry a funny look, then goes away and writes his own DIFFERENTIATE, using George's documentation for the old MAPCAR, of course, unaware that the new one has been installed...
George's new MAPCAR conceptually has state. The state information should be local to the definition of MAPCAR, because that information is not anyone else's business, and George has no business requiring everyone else to keep track of it for him. George and Harry and Bruce all wish George had a way to maintain local state information in MAPCAR.


## Side Effects and Local State

Traditionally local state is maintained through some sort of "side effect". We can always avoid the use of side effects if we are willing to pass all state variables around. As we have seen, this requires a monolithic conception of the program structure. If we wish to break a program up into independent modules, each with local state information, we must seek another method.
We claim that any such method effectively constitutes a side effect. If a module has hidden state, then its behavior can potentially change over time.
If only one module in the system has local state, then we can hide the side effect by making it the top-level module of the system, as we have done for DRIVER-LOOP. (For an example of this, see (Note Weber).) If more than one module has state, however, then each may perceive changes in the other's behavior. This the essence of side effect.
The concept of side effect is induced by particular choices of boundaries between parts of a larger system. If a system boundary encloses all processes of interest (the system is closed), we need no concept of side effect to describe that system as a whole in vacuo. If, however, we wish to make an abstraction by dividing the system into modules more than one of which has independent state, then we have by this action created the concept of side effect.
We are forced to introduce side effects as a technique for constructing modular systems. But side effects violate referential transparency by altering the meanings of expressions; we expect (+ 3 4) always to mean the same thing, but we cannot say the same for (+ 3 (RANDOM)). Two techniques for achieving modularity have come into direct conflict.
The most common form of side effect in programming languages is the assignment statement, which alters the meaning of a variable. LISP provides this notion in the SETQ construct:

(SETQ X 43) 

returns 43, and as a side effect alters the meaning of x so that subsequent references will obtain 43 also.
With this, George can now write:

(DEFINE (MAPCAR F L)
        (MAPCAR-1 F L (SETQ N (+ N 1))))

(DEFINE (MAPCAR-1 F L HUNOZ)
        (OLDMAPCAR F L))

There are still some minor problems here. The function MAPCAR1 and the variable HUNOZ are used solely to throw away the value of the SETQ form. It is 50 common to use SETQ only for its side effect that another construction, PROGN, is very useful:

(PROGN e_1 e_i ... e_N)

evaluates each of the forms e, in order, throwing away the values of all but the last one. Notice that we specifically require them to be evaluated in order; this concept did not occur in the specification of our earlier interpreters, because it was not necessary in the absence of side effects. Similarly, it was not useful to be able to throw away values in the absence of side effects. (We did throw away a value in DRIVER-LOOP, but that was one which resulted from calling PRINT, which of course is assumed to have a side effect!) Using PROGN, George can write: 

(DEFINE (MAPCAR F L)
        (PROGN (SETQ N (+ N 1))
               (OLDMAPCAR F L)))

There remains the problem of the global variable N, which Harry or Bruce might stumble across by accident. George has to have some handle to get at the statistics counter, and any handle George can use intentionally, Bruce and Harry can use accidentally. One thing that George can do is rename N to MAPCAR-STATISTICS-COUNTER, and warn Bruce and Harry not to use a global variable with that name. This is still better than the original situation at least now Bruce and Harry need not change their programs, and it is George's responsibility to find a name which does not conflict. {Note Can George do better?}
In the case of RANDOM, where the state information is truly local in that no one wants to access it except its owner, we can combine the use of lexical scoping and of side effects to manipulate a completely hidden state variable. For example, suppose we want several independent pseudo-random number generators, initialized with different seeds. We can make a pseudo-random number generator generator as follows:

(DEFINE (RGEN SEED) 
        (LAMBDA () (PROGN (SETQ SEED
                                ((LAMBDA (Z) (COND ((> Z 0) Z)
                                                   (T (+ Z -32768.))))
                                 (* SEED 899.)))
                          SEED)))

Each call to RGEN delivers as its value a new pseudo-random number generator which is an instance of the prototype described by the LAMBDA-expression which is the body of RGEN. Each one has a state variable which is its seed. The state of each instance is distinct from that of every other instance. This gives one the power of the own variables of ALGOL 60 without any additional mechanism.


## Side Effects in the Interpreter

In order to write a simple interpreter which implements the side effect SETQ, we will postulate the existence of two side effect operators which alter S-expressions:

(RPLACA X Y) and (RPLACD X Y)

return the value of x (which must not be atomic), but as a side effect alters × so that its car or cdr, respectively, is the value of Y. (The introduction of operators which modify S-expressions causes a number of nasty problems, which we will consider presently.) We will use these operators to alter the structure of the environment ENV. We modify EVAL to recognize the SETQ construct (see Figure 11). On seeing "SETQ" in the "operator position" of the expression, EVAL dispatches to EVSETQ, after recursively evaluating the value to be assigned. EVSETQ uses LOOKUP to find the effective binding of the variable mentioned in the SETQ. If there is such a binding, RPLACA is used to change the value associated with the variable. If there is no such binding, then the intent is to initialize a top-level variable; EV-TOP-LEVEL-SETQ locates the top-level environment (which is always at the end of any environment) and creates a new binding by altering the environment structure.
We also modify EVAL to recognize PROGN. EVPROGN is a tail-recursive loop which evaluates each subform of the PROGN form in turn, throwing away each value but the last. {Note PROGN Wizardry}

```lisp
(DEFINE (EVAL EXP ENV)
        (COND ((ATOM EXP)
               (COND ((NUMBERP EXP) EXP)
                     (T (VALUE EXP ENV))))
              ((EQ (CAR EXP) 'QUOTE)
               (CADR EXP))
              ((EQ (CAR EXP) 'LAMBDA)
               (LIST '&PROCEDURE (CADR EXP) (CADDR EXP) ENV))
              ((EQ (CAR EXP) 'SETQ)
               (EVSETQ (CADR EXP) (EVAL (CADDR EXP) ENV) ENV))
              ((EQ (CAR EXP) 'PROGN)
               (EVPROGN (CDR EXP) ENV NIL))
              ((EQ (CAR EXP) 'COND)
               (EVCOND (CDR EXP) ENV))
              (T (APPLY (EVAL (CAR EXP) ENV)
                        (EVLIS (CDR EXP) ENV)))))

(DEFINE (EVSETQ VAR VAL ENV)
        ((LAMBDA (SLOT)
                 (COND ((EQ SLOT '&UNBOUND)
                        (EV-TOP-LEVEL-SETQ VAR VAL ENV))
                       (T (CAR (RPLACA SLOT VAL)))))
         (LOOKUP VAR ENV)))

(DEFINE (EV-TOP-LEVEL-SETQ VAR VAL ENV)
        (COND ((NULL (CDR ENV))
               (CADAR (RPLACA ENV
                              (CONS (CONS VAR (CAAR ENV))
                                    (CONS VAL (CDAR ENV))))))
              (T (EV-TOP-LEVEL-SETQ VAR VAL (CDR ENV)))))

(DEFINE (EVPROGN EXPS ENV HUNOZ)
        (COND ((NULL (CDR EXPS)) (EVAL (CAR EXPS) ENV))
              (T (EVPROGN (CDR EXPS) ENV (EVAL (CAR EXPS) ENV)))))

For VALUE, LOOKUP, and BNID see Figure 3.
For EVCOND and EVLIS see Figure 5.
For APPLY see Figure 7.
For LOOKUP1 see Figure 10 (not Figure 3).

Figure 11
Evaluator with User Side Effects (Assignment to Variables)
```

Because EVSETQ can be used to initialize new top-level variables, it is convenient for DRIVER-LOOP-1 to call EVSETQ when defining a new function (see Figure 12). Unlike the DRIVER-LOOP-1 of Figure 10, this one has no special knowledge about the structure of environments; as before, such knowledge is hidden in environment specialists such as BIND, VALUE, and now EVSETQ. (The value of EVSETQ is not used, but thrown away; we introduce an extra throwaway parameter into the definition of DRIVER-LOOP for this purpose.)

```lisp
(DEFINE (DRIVER)
        (DRIVER-LOOP <THE -PRIMITIVE-PROCEDURES>
        NLI
        (PRINT '|LITHP ITH LITHTENING|)))

(DEFINE (DRIVER-LOOP ENV HUNOZ HUKAIRZ)
        (DRIVER-LOOP-1 ENV (READ)))

(DEFINE (DRIVER-LOOP-1 ENV FORM)
        (COND ((ATOM FORM)
               (DRIVER-LOOP ENV NLI (PRINT (EVAL FORM ENV))))
              ((EQ (CAR FORM) 'DEFINE)
               (DRIVER-LOOP ENV
                            (EVSETQ (CAADR FORM)
                                    (LIST '&LABELED
                                          (CDADR FORM)
                                          (CADDR FORM))
                                    ENV)
                            (PRINT (CAADR FORM))))
              (T (DRIVER-LOOP ENV NLI (PRINT (EVAL FORM ENV))))))

For EVSETQ see Figure 11.

Figure 12
Driver Loop for Evaluator with User Side Effects (Assignment to Variables)
```

(Once we have side effects, we don't really need the &LABELED device permit incremental definition of recursive functions; we can just perform a side effect on the top-level environment. We left the &LABELED device in Figure 12 for continuity with the previous examples. "Real" LISP systems use the side effect method. See {Note Driver Loop with Side Effects), and also (Note LABELS with Side Effects).)


## Equipotency of SETQ and RPLACA

We pulled a fast one when we introduced RPLACA and RPLACD for the sake of implementing SETQ (though we actually only used RPLACA). We used a side effect to define the implementation of side effects. While this makes a fine meta-circular description, it doesn't constitute a definition of side effects founded on the original meta-circular recursion equations interpreter. 
We could implement an interpreter which would define a side effect without itself using side effects. Such a definition would encapsulate the entire state of the user's data structures into a single interpreter data structure which is passed around by a top-level loop. Constructing such an interpreter would involve turning a regular interpreter inside out (in much the same way GAUSSIAN was everted in (Note Weber}). This is extremely difficult and lengthy, and the module boundaries within the interpreter are so destroyed that the resulting interpreter is nearly impossible to understand. We will spare the reader the details. 
We settle for a meta-circular description of side effects. Now that we have seen how to implement SETQ in terms of RPLACA and RPLACD, we can also do the reverse, completing the meta-circle (see Figure 13). We use the procedural version of CONS shown earlier, modified to provide two "setting procedures" SA and SD, which provide the ability to alter the car and cdr.

```lisp
(DEFINE (CONS A D)
        (LAMBDA (M)
                (M A D (LAMBDA (Z) (SETQ A Z)) (LAMBDA (Z) (SETQ D Z)))))

(DEFINE (CAR X)
        (X (LAMBDA (A D SA SD) A)))

(DEFINE (CDR X)
        (X (LAMBDA (A D AS SD) D)))

(DEFINE (RPLACA X Y)
        (X (LAMBDA (A D AS SD)
                   (PROGN (SA Y) X))))

(DEFINE (RPLACO XY)
        (X (LAMBDA (A D AS SD)
                   (PROGN (SD Y) X))))

Figure 13
Procedural ("Actors-like") Implementation of CONS and Friends
```

We originally introduced side effects such as SETQ to help us build modules such as RANDOM which have local state. Now, using the technique of constructing procedures, we find that CONS can be viewed as a constructor of modules, just as MAPGEN was. 
CONS Constructs modules ("cons cells") which use SETQ to maintain a local state. 


## Side Effects and Equality

"Things are seldom what they seem, Skim milk masquerades as cream..." 
- Gilbert and Sullivan (H.M.S. Pinafore)

"Plus ça change, plus c'est la même chose."
- Alphonse Karr


Our descriptions of SETQ and RPLACA, both informal and meta-circular, are imprecise. They admit a number of drastically different interpretations of the behavior of the system. We would all agree that for RPLACA to mean anything at all like what we want, the expression:

```lisp
((LAMBDA (X) 
         (PROGN (RPLACA X 'Z)
                (CAR X)))
 (CONS 'A '(B C)))

Puzzle #1 
```

should evaluate to Z. But what about this case:

```lisp
((LAMBDA (X Y) 
         (PROGN (RPLACA X 'Z)
                (CAR Y)))
 (CONS 'A '(B C))
 (CONS 'A '(B C))) 

Puzzle #2 
```

Should this evaluate to A or Z? Nearly all LISP systems would produce A, but there are arguments for both possibilities. Similarly, should this:

```lisp
((LAMBDA (X)
         ((LAMBDA (U V)
                  (PROGN (RPLACA U 'Z)
                         (CAR V)))
          X X))
 (CONS 'A '(B C)))

Puzzle #3
```

evaluate to A or Z? Again there are arguments for both possibilities. 
Before we can meaningfully consider these questions, we must have a precise notion of what we mean by "RPLACA". Let us review its description:

If x has as its value a non-atomic S-expression, and we evaluate the expression (RPLACA X Y), then after this evaluation, the value of the expression (CAR X) is Y. 

This description depends upon a critical assumption. We have a notion of a thing which is the value of X, such that several references to the variable X all refer to the same thing. But what the $&*#@ do we mean by "same"??
The concept of side effect is inseparable from the notion of equality/identity/sameness. The only way one can observationally determine that a side effect has occurred is when the same object behaves in two different ways at different times. (Note RPLACA Can Alter CAR Instead} Conversely, the only way one can determine that two objects are the same is to perform a side effect on one and look for an appropriate change in the behavior of the other.
In order to determine the answers to the Puzzles above, we must determine what properties are required of "sameness". There may be different points of view regarding sameness, which may lead to different answers to the Puzzles. 
If we agree that the answer to Puzzle #1 is z, then we have implicitly adopted the notion of consistency of variable reference, because we have referred to the variable x twice. As a property of the sameness predicate ≡, we write: (≡ X X). We can say that referring to a variable does not make a copy of its value (because if it did, the RPLACA in Puzzle #1 would have changed only a copy of the value of x, and (CAR X) would extract the car of a different copy, producing A).
Given this, and given that we accept the interpreter of Figure 11 and believe in its meta-circularity, we are forced to conclude that the answer to Puzzle #3 is also z. We must consider all access paths and show that no copying can occur which would allow the answer to be A. The meta-circularity requires that any property of the interpreted language also hold for the text of the interpreter, and vice, versa. The answer to Puzzle #1 requires that variable references not produce implicit copies, and so neither can variable references in the text of the interpreter. (Consistent with this, our particular interpreter has no explicit code in LOOKUP which specifies copying.) The other place in Puzzle #3 where copying might occur is in the binding of U and V. Examining the text of our particular meta-circular interpreter shows that BIND also has no explicit code for copying. There remains the possibility that binding does implicitly copy in the text of the meta-circular interpreter; this would consistently cause copying in the bindings of the interpreted code, because ENV would be copied whenever bound in the text of the interpreter. This, however, would cause the answer to Puzzle #1 to be A, because ENV is bound at other places which would cause incorrect copying. We therefore conclude that no implicit copying can occur, and so the answer to Puzzle #3 is z. 
We emphasize that this result rests on our acceptance of а particular class of meta-circular interpreters. (These interpreters, however, closely model what real LISP systems do.) There are other languages which do implicitly copy structured values when binding variables, such as Algol 60 when using call-by-value. For such a language, the answer to Puzzle #3 would be A (if we represented the list (A B C) as an Algol 60 array, for example), even though the answer to Puzzle #1 would still be Z. 
One can argue both for and against copying during binding on the basis of modularity. Copying isolates the caller from the called routine by preventing the called routine from performing under-the-table side- effects on the caller's data objects. Not copying allows data objects to encapsulate independent pieces of state which can be operated on by low-level routines whose details need not be understood by their caller (an example of such a data object is the symbol table of an assembler, with its insertion and lookup routines). 
We now consider Puzzle #2. If we accept that binding and variable referencing do not makes copies, then Puzzle #2 is a question about the nature of CONS: if CONS is called twice with arguments which are the same, are the two results the same? (Note that this is the inverse of Postulate 4 for S-expressions in {Note S-expression Postulates and Notation}.) If the answer is consistently A (as in most real LISP systems), then coNs must generate a new object every time it is called. (It must produce different results if the two sets of arguments differ, and an answer of A to Puzzle #2 requires different results if the two sets of arguments are the same.) CONS perforce contains a side effect. Calls to it are not referentially transparent. 
The other possibility, given that variable binding and variable referencing do not make copies, is that the answer to Puzzle #2 is z. In this case, CONS of the same arguments must always produce the same result. This choice leads to galloping non-modularity of data structures without compensation. Suppose, for example, we 
we represent arrays as lists of numbers (a reasonable LISP representation), and want to alter the last element of one such array (using RPLACA). Under this scheme, all arrays whatsoever with the same last element would be magically altered! A language with such characteristics would be extremely difficult to control. 
Supposing now that binding does make copies as in Algol 60, the answer to Puzzle #2 must be A. Here it does not matter whether CONS of the same arguments produces the same result, since the bindings of x and y will make copies anyway. We may, however, consider this variant:

```lisp
(PROGN (RPLACA (CONS 'A '(B C)) 'Z)
       (CAR (CONS 'A '(B C))))

Puzzle #2a 
```

Here we have simply substituted the expressions (CONS 'A '(B C)) for the occurrences of X and Y. If CONS always returns the same object for the same inputs, then Puzzle #2 and Puzzle #2a have different answers if bindings copy, but may have the same answers if bindings do not copy (they may not have the same answer if CONS notices that we have pulled the rug out from under it and produces a new version because the old one was changed!). There is also a quibble as to whether the passing of an argument to RPLACA in itself constitutes a binding - if so, RPLACA must be completely ineffectual, because it always receives a copy! We must then regard RPLACA as a built-in system primitive; the user would have no way to define such a thing. This would be most unfortunate.
We have examined many of the design decisions for the meaning of RPLACA, CONS, and equality. If side effects are to be usable at all, the references to things denoted by variables must not make copies of those things. If the user is to be able to write procedures which produce lasting side. effects on their arguments (as system-supplied primitive operators do), then there must be a variable binding mechanism which does not make copies. (LISP's binding mechanism in fact does not copy. Algol 60's call-by-value mechanism does copy structured data, but its call-by- name mechanism does not; we will study this in Part Three.) If the variable binding (or assignment) mechanism does not make copies, then CONS must generate a new, distinct object on each call.
The reader may have noted that we have been talking in circles for the last several paragraphs: in attempting to elucidate the meaning of sameness, we have discussed side effects, and in so doing used the word "same" nearly every other sentence. The point is that it is not possible to define them separately; The meanings of "equality" and "side effect" simultaneously constrain each other. With this in mind, we will investigate the choice of a primitive equality predicate.
The equality predicate we choose should be sufficiently finely grained to distinguish any two objects which have potentially distinct behavior, yet should not be so finely grained as to distinguish entities which otherwise would have the same behavior. Thus we have two desiderata:

[1] Two objects which are observed to behave differently must not be equal. 
[2] Conversely, we would like two objects which are adjudged unequal to exhibit differing behaviors under suitable circumstances.

Any useful equality predicate must satisfy [1]. Unfortunately, satisfying [2] also may be too difficult; the equivalence of behavior for procedural objects is an unsolvable problem. We are thus forced to settle for an equality predicate which may make more distinctions than are strictly necessary.
LISP has two standard equality predicates: EQUAL and EQ. We exhibited a definition of EQUAL in Part Zero. In Part Zero we also gave a description of EQ, but defined it only on atoms; LISP usually extends EQ to all S-expressions in such a way as to distinguish the results of different calls to CONS (regardless of the arguments given to CONS). Variable references and variable binding "preserve EQness".
In the absence of RPLACA ("pure LISP"), EQ and EQUAL both satisfy desideratum [1]. EQUAL, however, makes fewer unnecessary distinctions than EQ. By desideratum [2], EQUAL is therefore preferred to EQ. (The technique of "hash-consing" [Goto] can be used in this situation to make EQ and EQUAL effectively the same.)
In the presence of side effects such as RPLACA, EQUAL fails to make sufficiently many distinctions. Each call to CONS produces distinct objects, which EQUAL may fail to distinguish. In this case, EQUAL fails desideratum [1]. Thus, in the presence of RPLACA, EQ is the preferred equality predicate.
In summary, indeed "the more things change, the more they remain the same". Two distinct objects may look the same because one masquerades as the other; they can be operationally distinguished only by purposely altering the behavior of just one of them. Thus the ability to decide whether two objects are the same is directly correlated with the ability to perform side effects on them.

## Dynamic Scoping as a State-Decomposition Discipline

As we saw in the preceding section, side effects can become rather complicated. To help keep this complexity under control, we ought to abstract and package common patterns of their use.
Suppose we have a procedure PRINT-NUMBER which prints numbers:

(DEFINE (PRINT-NUMBER N) 
        ((LAMBDA (Q R)
                 (COND ((ZEROP Q) (PRINT-DIGIT R))
                       (T (PROGN (PRINT-NUMBER Q)
                                 (PRINT-DIGIT R)))))
         (/ N 10.)
         (REMAINDER N 10.)))

Now people find this program very useful and use it in all their programs.
Normally we want to print numbers in radix 10 (decimal), but occasionally (for example, in a debugging aid) we want to print numbers in other radices, such as 8 or 16. One might generalize the PRINT-NUMBER program to take the radix as an extra argument: 

(DEFINE (PRINT-NUMBER N RADIX)
        ((LAMBDA (Q R)
                 (COND ((ZEROP Q) (PRINT-DIGIT R))
                       (T (PROGN (PRINT-NUMBER Q)
                                 (PRINT-DIGIT R)))))
         (/ N RADIX)
         (REMAINDER N RADIX)))

Of course, then everyone who uses PRINT-NUMBER must supply the radix. This is mildly annoying, because most of the time one wants decimal printing, and one tires of writing "10." all the time. One might write another program for most people to use:

(DEFINE (PRINT-10 N) 
        (PRINT-NUMBER N 10.))

This example is simple, but a real PRINT procedure in a real LISP system may be controlled by dozens of parameters like RADIX: format parameters for printing floating-point numbers, which file to print to, file-dependent format parameters such as line width and page length, file-dependent processing routines (e.g. scrolling for display terminals), abbreviation format parameters for S-expressions, etc. All these extra parameters to PRINT are really determined by the larger context in which PRINT is used, but this context is usually not determined by the immediate caller of PRINT. A program which generates and prints successive prime numbers should not have to deal with the complexities of output files; in particular, one does not want to have to rewrite the program just to direct the output to a line printer instead of a disk file. Context decisions are usually made at a much higher level (perhaps interactively by the user). Therefore the solution of using procedures like PRINT-10 is not acceptable; such procedures only serve as abbreviations, binding the many parameters to constants at too low a decision level.
Another idea is to pass the extra parameters for print control through the intermediate levels of the program. But this violates the modularity of the intermediate modules, which generally have no interest in PRINT'S screwy parameters. On the other hand, an occasional intermediate module will be interested in dealing with a few of the parameters (but probably not all of them!). We would like a mechanism for dealing with only the parameters of interest, without having to deal with all of them all of the time.
Side effects can do the job. We can make all the parameters globally available variables (in the top-level environment), initialized to reasonable default values, and invite all interested parties to perform SETQ as necessary. This technique has disadvantages. If every program just changes the parameters at will, then each program must re-set all the parameters (even the ones not of interest) for its own uses of PRINT. This is even worse than just passing PRINT all the parameters!
We can require a convention whereby the parameters normally have their initial default values, and any program which modifies a parameter must eventually restore it to its previous value. For example, a procedure to print in octal might look like:

(DEFINE (PRINT-8 N) 
        ((LAMBDA (OLDRADIX)
                 (PROGN (SETQ RADIX 8)
                        (PRINT-NUMBER N)
                        (SETQ RADIX OLDRADIX)))
         RADIX))

This convention allows PRINT-8 to locally alter the radix, in a manner transparent to its caller; it does not interfere with the way in which its caller may be using PRINT.
This convention is a standard pattern of use. It is a stack discipline on the values of RADIX (or whatever other variables). We would like to capture this pattern as an abstraction in our language.
Surprise! We have seen this abstraction before: dynamically Scoped variables behave in precisely this way. Dynamically scoped variables conceptually have a built-in side effect we took advantage of this at the end of Part One to fix the problem with the top-level loop. Binding a dynamically scoped variable such as RADIX can be said to cause a side effect because it alters the behavior of a (superficially) unrelated procedure such as PRINT in a referentially opaque manner. Such binding is a particularly structured kind of side effect, because it guarantees that the side effect will be properly undone when the binder has finished executing. Thus with dynamic scoping we could write:

(DEFINE (PRINT-8 N)
        ((LAMBDA (RADIX)
                 (PRINT-NUMBER N))
         8))

We saw in Part One that, precisely because dynamically scoped variables are referentially opaque, we do not want all variables to be dynamically scoped. But we have newly rediscovered dynamic variables in another context and found them desirable. We therefore consider an interpreter which supplies both lexical and dynamic variables (see Figure 14).
Here we have merged the dynamically scoped variable evaluator (Figure 5) with the lexically scoped evaluator (Figure 11). We changed APPLY to have an extra case, wherein an "open LAMBDA-expression" is effectively closed at the time of its application using the environment of its caller. EVAL is changed to once again supply the environment to APPLY. This interpreter is almost identical to that of LISP 1.5 [LISP 1.5M], with the difference that we write simply (LAMBDA ...) to get a closed procedure where in LISP 1.5 one must write (FUNCTION (LAMBDA ...)); in both cases one 
must write '(LAMBDA ...) to get an open LAMBDA-expression. 

```lisp
(DEFINE (EVAL EXP ENV)
        (COND ((ATOM EXP)
               (COND ((NUMBERP EXP) EXP)
                     (T (VALUE EXP ENV))))
              ((EQ (CAR EXP) 'QUOTE)
               (CADR EXP))
              ((EQ (CAR EXP) 'LAMBDA)
               (LIST '&PROCEDURE (CADR EXP) (CADDR EXP) ENV))
              ((EQ (CAR EXP) 'SETQ)
               (EVSETQ (CADR EXP) (EVAL (CADDR EXP) ENV) ENV))
              ((EQ (CAR EXP) 'PROGN)
               (EVPROGN (CDR EXP) ENV NIL))
              ((EQ (CAR EXP) 'COND)
               (EVCOND (CDR EXP) ENV))
              (T (APPLY (EVAL (CAR EXP) ENV)
                              (EVLIS (CDR EXP) ENV)
                              ENV))))

(DEFINE (APPLY FUN ARGS ENV)
        (COND ((PRIMOP FUN) (PRIMOP-APPLY FUN ARGS))
              ((EQ (CAR FUN) '&PROCEDURE)
               (EVAL (CADDR FUN)
                     (BIND (CADR FUN) ARGS (CADDDR FUN))))
              ((EQ (CAR FUN) 'LAMBDA)
               (EVAL (CADDR FUN)
                     (BIND (CADR FUN) ARGS ENV)))
              (T (ERROR))))

For VALUE, LOOKUP, and BIND see Figure 3.
For EVCOND and EVLIS see see Figure 5.
For LOOKUP1 see Figure 10 (not Figure 3).

Figure 14
Interpreter with Both Open and Closed Procedures
```

Although this is the tradition, it doesn't work very well. The problem is that the lexical variables are not really lexical. Although lexical references cannot incorrectly refer to dynamically intended bindings, the reverse is not true. Dynamic variable references can be captured by bindings intended to be strictly lexical. 
For example, we might want to write a procedure which packages up information about dealing with RADIX:

(DEFINE (RADIX-10 FUN) 
        ((LAMBDA (RADIX) (FUN))
         10.))

This is more general than PRINT-10 in that it allows us to wrap a binding of RADIX around any piece of code, not just a call to PRINT. (In a more realistic example, we might package up the bindings of a dozen parameters in a similar manner.) 
There are two possibilities: should the argument to RADIX-10 be a closed procedure or an open LAMBDA-expression? If closed:

(DEFINE (DO-SOMETHING-INTERESTING X FUN) 
        (RADIX-10 (LAMBDA () (FORMAT-HAIR 'FOO (CADR X) FUN))))

(FORMAT-HAIR takes several arguments, one of them a procedure and presumably calls PRINT at some level), then the binding of RADIX in RADIX-10 will not be apparent to PRINT, because the environment of the call to FORMAT-HAIR is that of the closed procedure, which in turn is that of the call to RADIX-10 within DO-SOMETHING-INTERESTING. Thus it fails to work at all. If the argument to RADIX-10 is left open:

(DEFINE (DO-SOMETHING-INTERESTING X FUN) 
        (RADIX-10 '(LAMBDA () (FORMAT-HAIR 'FOO (CADR X) FUN))))

then this fails to work at all because of a variable naming conflict with FUN. The third argument passed to FORMAT-HAIR Will evaluate to the argument which was passed to RADIX-10, namely the quoted lambda expression. This is similar to the MAPCAR bug that originally got us thinking about lexical scoping in Part One.
A solution to this problem is to maintain separate environments for lexical and dynamic variables; this will guarantee that the two kinds cannot interfere with each other. This will require a special syntax for distinguishing references to and bindings of the two kinds of variables. We will choose to encode lexical variables as atomic symbols, as before, and dynamic variables as lists of the form (DYNAMIC x), where x is the name of the dynamic variable. (This choice is completely arbitrary. We could have chosen to encode the two kinds as (LEXICAL ×) and x; or as (LEXICAL ×) and (DYNAMIC x), leaving atomic symbols as such free to encode yet something else; but we have chosen this because in practice most variable references, even in a purely dynamically scoped LISP, are lexical, or can be considered so.)
In our new interpreter (see Figure 15) we call the two environments ENV (lexical) and DENV (dynamic). The syntax of LAMBDA-expressions is extended to accommodate two kinds of bindings; for example,

(LAMBDA (X Y (DYNAMIC Z) W) ...)

takes four arguments, and binds the parameters X, Y, and w lexically, and z dynamically. Using this syntax, we could write RADIX-10 in this way:

(DEFINE (RADIX-10 FUN) 
        ((LAMBDA ((DYNAMIC RADIX)) (FUN)) 
         10.))

The code for PRINT-NUMBER would then be written:

(DEFINE (PRINT-NUMBER N) 
        ((LAMBDA (Q R)
                 (COND ((ZEROP Q) (PRINT-DIGIT R))
                       (T (PROGN (PRINT-NUMBER Q)
                                 (PRINT-DIGIT R)))))
         (/ N (DYNAMIC RADIX))
         (REMAINDER N (DYNAMIC RADIX))))

Most of the extra complexity in Figure 15 is devoted to the parsing of LAMBDA-expression binding lists upon application by APPLY-PROCEDURE. (For the sake of brevity we have omitted the parts of the interpreter which deal with SETQ and PROGN; they could easily be re-inserted.)

```lisp
(DEFINE (EVAL EXP ENV DENV)
        (COND ((ATOM EXP)
               (COND ((NUMBERP EXP) EXP)
                     (T (VALUE EXP ENV))))
              ((EQ (CAR EXP) 'QUOTE) (CADR EXP))
              ((EQ (CAR EXP) 'LAMBDA)
               (LIST '&PROCEDURE (CADR EXP) (CADDR EXP) ENV))
              ((EQ (CAR EXP) 'COND)
               (EVCOND (CDR EXP) ENV DENV))
              ((EQ (CAR EXP) 'DYNAMIC) (VALUE (CADR EXP) DENV))
              (T (APPLY (EVAL (CAR EXP) ENV DENV)
                        (EVLIS (CDR EXP) ENV DENV)
                        DENV))))

(DEFINE (APPLY FUN ARGS DENV)
        (COND ((PRIMOP FUN) (PRIMOP-APPLY FUN ARGS DENV))
              ((EQ (CAR FUN) '&PROCEDURE)
               (APLY-PROCEDURE (CADR FUN) ARGS '() '() '() '()
                               (CADDDR FUN) DENV (CADDR FUN)))
              (T (ERROR))))

(DEFINE (APPLY-PROCEDURE VARS ARGS LVARS LARGS DVARS DARGS ENV DENV BODY)
        (COND ((NULL VARS)
               (COND ((NULL ARGS)
                      (EVAL BODY
                            (BIND LVARS LARGS ENV)
                            (BIND DVARS DARGS DENV)))
                     (T (ERROR))))
              ((NULL ARGS) (ERROR))
              ((ATOM (CAR VARS))
               (APPLY-PROCEDURE (CDR VARS) (CDR ARGS)
                                (CONS (CAR VARS) LVARS) (CONS (CAR ARGS) LARGS)
                                DVARS DARGS
                                ENV DENV BODY))
              ((EQ (CAAR VARS) 'DYNAMIC)
               (APPLY-PROCEDURE (CDR VARS) (CDR ARGS)
                                LVARS LARGS
                                (CONS (CAR VARS) DVARS) (CONS (CAR ARGS) DARGS)
                                ENV DENV BODY))
              (T (ERROR))))
For EVCOND and EVLIS see Figure 2.
For VALUE, BIND, and LOOkUP see Figure 3.
For LOOKUP1 see Figure 10.

Figure 15
Interpreter with Separate Lexical and Dynamic Variables
```

Dynamic scoping provides an important abstraction for dealing with side effects in a controlled way. A low-level procedure may have state variables which are not of interest to intermediate routines, but which must be controlled at a high level. Dynamic scoping allows any procedure to get access to parts of the state when necessary, but permits most procedures to ignore the existence of the state variables. The existence of many dynamic variables permits the decomposition of the state in such a way that only the part of interest need be dealt with. 
If dynamic variables are integrated with the lexical environment, intractable dilemmas are encountered. (We have not considered here all possible such integration schemes, but the authors have found such difficulties with every such scheme they have examined.) We have therefore presented an interpreter in which environments for the two kinds of variable are separated.


# Summary

We examined the effects of various language design decisions on the programming styles available to a user of the language, with particular emphasis on the ability to incrementally construct modular systems. At each step we exhibited an interactive meta-circular interpreter for the language under consideration. Each new interpreter was the result of an incremental change to the previous interpreter.
We started with a simple interpreter for LISP recursion equations. In order to capture certain abstractions we were forced to introduce procedural data. This in turn forced consideration of the meanings of free variables in a procedure, for the simplest extension unexpectedly introduced dynamic scoping of variables.
We were compelled to turn from dynamic scoping to lexical scoping to preserve the integrity of procedural abstractions. The referentially transparent language thus obtained is richer than expected. It allows the definition of procedures which construct other procedures by instantiation of a prototype. Unfortunately, we found that complete referential transparency in a language makes it impossible to construct an interactive interface to the interpreter. But such an interface is necessary to satisfy another requirement of modular construction: that parts of a program can be independently defined, replaced, and debugged. We were forced to give up absolute referential transparency to admit an interactive interface.
The problems of the interactive interface led us to consider the notion of state as a dimension of abstraction. Just as we didn't want to have textually monolithic programs, we wanted to avoid programs which manipulate a monolithic representation of the state. The decomposition of the state of a system into several independent parts induces the notion of a side effect. Side effects only make sense relative to a definition of equality on the space of data objects. But the definition of equality itself depends simultaneously on the notion of side effect. Only a few of the choices of equality predicate and side effect notion are consistent with the requirements of modular construction.
The introduction of side effects is inconsistent with referential transparency. But since both are important to support modular construction we must accept an engineering trade-off between them. We were led to look for controlled patterns of side effects which can be easily understood and safely applied. We discovered that one such pattern is equivalent to the use of dynamically scoped variables we discussed earlier. We investigated how to construct a system which integrates lexical and dynamic scoping in a smooth way.
There are many issues yet to be explored. The introduction of side effects raises questions about order of evaluation. An interesting order provided by Algol 60 is call-by-name. This discipline, so unlike LISP's, is induced from a different notion of procedure, expressed as the "copy rule". This idea is a syntactic one, and so differs in flavor from the procedural ideas embodied by the interpreters we have presented. Consideration of syntactic transformations leads to the notion of procedures, such as macros, compilers, and simplifiers. We will explore all of this in Parts Three and Four. 


# Acknowledgements

We would like to thank Johan De Kleer, Daniel L. Weinreb, Julie Sussman, Carl Hewitt, Richard Stallman, Jon Doyle, and Mitch Marcus for reading our draft. They found few bugs and helped us refine our presentation. We also want to thank Hal Abelson and Robert Fano for help and encouragement. Finally, we must thank John McCarthy. Besides responding to our messages and answering questions about the early history of LISP, it was all his idea in the first place and we are continually amazed at the beauty and power of his conception.

# Notes

## {Can George do Better?}

The problem here is that George needs access to the statistics counter without giving that access to anyone else. As described in the next example George can make the counter an own variable, but how can he get access to it? One idea is that George can define MAPCAR in the following manner:

((LAMBDA (N) 
         (PROGN (SETQ MAPCAR 
                      (LAMBDA (F L)
                              (PROGN (SETQ N (+ N 1))
                                     (OLDMAPCAR F L))))
                (LAMBDA () N)))
 0)

This expression defines MAPCAR by SETQing (See (Note Driver Loop with Side Effects}.) it to an appropriate procedure. It then returns, as a value, an anonymous procedure which accesses the value of the statistics counter. If George saves this value and uses it to get at the counter when he needs it, he will have isolated it completely from everyone else!


## {Debugging}


It has been suggested that it is possible always to write correct programs. Such a situation would eliminate the need for debugging. The problem with this idea is that a crucial part of the problem-solving strategy is the decomposition of problems into presumably independent subproblems. There is no guarantee that this is possible in general, but even when it is not possible, there are often general strategies for approximating a solution to a problem by composing the solutions to almost independent subproblems. Often one can make progress on the solution to a hard problem by considering the solution of a simplified version of the problem which is similar in some essential aspect to the original one but which differs from it in detail. Once the solutions to the subproblems are obtained, they must be fitted together, and the details of the interactions smoothed out. The fixing of unanticipated interactions is debugging.
Even in those cases where a decomposition into completely independent subproblems is possible, it is not always feasible. In order to be sure that the solutions to the subproblems are really independent it is necessary to understand both the problem and the possible implementations and interactions of subsolutions so completely that one must effectively solve the entire problem before choosing the correct decomposition. This compromises the decomposition strategy.


## {Driver Loop with Side Effects}

This driver loop (Figure N1) is similar to the one in Figure 8 (which didn't work). This one does work because, although top-level procedure definitions are closed in the current top-level environment, that environment is changed using a side effect when new definitions are made.

```lisp
(DEFINE (DRIVER-LOOP-1 ENV FORM)
        (COND ((ATOM FORM)
               (DRIVER-LOOP ENV NIL (PRINT (EVAL FORM ENV))))
              ((EQ (CAR FORM) 'DEFINE)
               (DRIVER-LOOP ENV
                            (EVSETQ (CAADR FORM)
                                    (LIST '&PROCEDURE
                                          (CDADR FORM)
                                          (CADDR FORM)
                                          ENV)
                                    ENV)
                            (PRINT (CAADR FORM))))
              (T (DRIVER-LOOP ENV NIL (PRINT (EVAL FORM ENV))))))

For EVAL and EVSETQ see Figure 11.
For LOOKUP1 see Figure 3 (not Figure 10, despite Figure 11!).

Figure N1 
Implementation of DRIVER-LOOP Using Side Effects
```

## {EVALQUOTE}

The top level of LISP 1 [LISP 1M] and LISP 1.5 [LISP 1.5M] actually was not at all like the one presented here. Rather than reading one S- expression and giving it to EVAL, it read two S-expressions and gave them to APPLY. Such a top level is called an EVALQUOTE top level (see Figure N2). 

```lisp
(DEFINE (DRIVER-LOOP-1 PROCEDURES FORM1)
        (DRIVER-LOOP-2 PROCEDURES FORM1 (READ)))

(DEFINE (DRIVER-LOOP-2 PROCEDURES FORM1 FORM2)
        (COND ((EQ FORM1 'DEFINE)
               (DRIVER-LOOP (BIND (LIST (CAAR FORM2))
                                  (LIST (LIST '&PROCEDURE (CDAR FORM2) (CADR FORM2)))
                                  PROCEDURES)
                            (PRINT (CAAR FORM2))))
              (T (DRIVER-LOOP PROCEDURES
                              (PRINT (APPLY FORM1 FORM2 PROCEDURES))))))

For DRIVER-LOOP see Figure 1.
For APPLY see Figure 2.
For BIND see Figure 3.

Figure N2
Driver Loop for an EVALQUOTE Top Level
```

This driver loop is somewhat nicer than the one in Figure 1, because the one in Figure 1 had an essentially useless COND clause. The case of typing an atom was not useful, because there were no top-level values for variables. Once we introduce procedural objects, this is no longer true. But EVALQUOTE requires an inconsistency of notation: at the top level one must write CAR((A . B)), whereas in the middle of a program one would write (CAR '(A . B)). 
The notion of EVALQUOTE also has some theoretical motivation, if one thinks of LISP as a universal machine akin to a universal Turing machine. In this model one takes a description of a machine to be simulated and a description of its input data, and gives them to the universal machine to process. In LISP, the universal machine is APPLY. 


## {Gaussian}

A typical example of the use of a pseudo-random number generator is to construct a generator for pseudo-random numbers with a Gaussian distribution by adding up a large number of uniformly distributed pseudo-random numbers. We would like to write it in roughly as in Figure N3. 

```lisp
(DEFINE (GAUSSIAN)
        (WEBER 0 43))

(DEFINE (WEBER X N)
        (COND ((= N 0) X)
              (T (WEBER (+ X (RANDOM)) (- N 1)))))

Figure N3
"Gaussian" Pseudo-Random Number Generator
```

This code should add up 43 pseudo-random numbers obtained by calling RANDOM. We cannot write such a RANDOM without side effects, however. We can arrange to pass the seed around, as in Figure N4.

```lisp
(DEFINE (GAUSSIAN SEED)
        (WEBER 0 43 SEED))

(DEFINE (WEBER X N SEED)
        (COND (( = N 0) (CONS X SEED))
              (T ((LAMBDA (NEWSEED)
                          (WEBER (+ X NEWSEED) (- N 1) NEWSEED))
                  (RANDOM SEED)))))

Figure N4
"Gaussian" Pseudo-Random Number Generator, Passing SEED
```

This is much more complicated. The user of GAUSSIAN must maintain the seed. Moreover, GAUSSIAN and WEBER each need to return two values; here we cons 
them together, and the user must take them apart. 


## {LABELS}

This technique can be generalized to allow the definition of recursive local procedures. (Although the Y-operator discussed in (Note Y- operator} can be used to implement recursive local procedures, it is extremely painful to construct several mutually recursive procedures. Although mutually recursive procedures can be theoretically eliminated (by procedure integration), this process destroys the conceptual structure of the program.)
Consider writing a procedure to construct the reverse of a given list:

(DEFINE (REVERSE L) 
        (REVERSE1 L '()))

(DEFINE (REVERSE1 OLD NEW)
        (COND ((NULL OLD) NEW)
              (T (REVERSE1 (CDR OLD) (CONS (CAR OLD) NEW)))))

The procedure REVERSE1 is irrelevant to the outside world; we would like to hide it inside REVERSE.
Let us invent a new construction to permit the definition of local procedure definitions with names:

(LABELS (((f_1 v_11 v_12 ...) body_1)
         ((f_2 v_21 v_22 ...) body_2)
         ...
         ((f_N v_N1 v_N2 ...) body_N))
         body)

means the value of 'body' when evaluated in an environment where the specified procedure definitions are available. For example:

(DEFINE (REVERSE L)
        (LABELS (((REVERSE1 OLD NEW)
                  (COND ((NULL OLD) NEW)
                        (T (REVERSE1 (CDR OLD) (CONS (CAR OLD) NEW))))))
                (REVERSE1 L '())))

The same trick works for LABELS as for the top level: when LOOKUP1 has found а LABELS-defined function, it has the correct environment in hand for constructing a &PROCEDURE-object. We need only add a test in EVAL for the LABELS construct, and arrange for the appropriate &LABELED-objects to be constructed (see Figure N5). 

```lisp
(DEFINE (EVAL EXP ENV)
        (COND ((ATOM EXP)
               (COND ((NUMBERP EXP) EXP)
                     (T (VALUE EXP ENV))))
              ((EQ (CAR EXP) 'QUOTE)
               (CADR EXP))
              ((EQ (CAR EXP) 'LAMBDA)
               (LIST '&PROCEDURE (CADR EXP) (CADDR EXP) ENV))
              ((EQ (CAR EXP) 'LABELS)
               (EVLABELS (CADR EXP) EXP '() '() ENV))
              ((EQ (CAR EXP) 'COND)
               (EVCOND (CDR EXP) ENV))
              (T (APPLY (EVAL (CAR EXP) ENV)
                        (EVLIS (CDR EXP) ENV)))))

(DEFINE (EVLABELS DEFINITIONS EXP NAMES FNS ENV)
        (COND ((NULL DEFINITIONS)
               (EVAL (CADDR EXP) (BIND NAMES FNS ENV)))
              (T (EVLABELS (CDR DEFINITIONS)
                           EXP
                           (CONS (CAAAR DEFINITIONS) NAMES)
                           (CONS (LIST '&LABELED
                                       (CDAAR DEFINITIONS)
                                       (CADAR DEFINITIONS))
                                 FNS)
                           ENV))))

For VALUE, LOOKUP, and BIND see Figure 3.
For EVCOND and EVLIS see Figure 5.
For APPLY see Figure 7.
For LOOKUP1 see Figure 10 (not Figure 3).

Figure N5
An Evaluator For Local Lexical Scoping,
Dynamic Top-Level References,
and Local Definition of Recursive Procedures
```

## {LABELS with Side Effects}

This implementation of LABELS (see Figure N6) applies the technique of {Note Driver Loop with Side Effects) to the implementation of LABELS in {Note LABELS). This is in fact how LABELS (or its cousin LABEL) is usually implemented in "real" LISP systems. 

```lisp
(DEFINE (EVLABELS DEFINITIONS EXP NAMES FNS ENV)
        (COND ((NULL DEFINITIONS)
               (EVLABELS-CLOSE (CADR EXP) EXP NIL (BIND NAMES FNS ENV)))
              (T (EVLABELS (CDR DEFINITIONS)
                           EXP
                           (CONS (CAAR DEFINITIONS) NAMES)
                           (CONS '&UNASSIGNED FNS)
                           ENV))))

(DEFINE (EVLABELS-CLOSE DEFINITIONS EXP VALS ENV)
        (COND ((NULL DEFINITIONS)
               (EVLABELS-CLOBBER NIL EXP (CDAR ENV) VALS ENV))
              (T (EVLABELS-CLOSE (CDR DEFINITIONS)
                                 EXP
                                 (CONS (LIST '&PROCEDURE
                                             (CDAAR DEFINITIONS)
                                             (CADAR DEFINITIONS)
                                             ENV)
                                       VALS)
                                 ENV))))

(DEFINE (EVLABELS-CLOBBER HUNOZ EXP SLOTS VALS ENV)
        (COND ((NULL VALS)
               (EVAL (CADDR EXP) ENV))
              (T (EVLABELS-CLOBBER (RPLACA SLOTS (CAR VALS))
                                   EXP
                                   (CDR SLOTS)
                                   (CDR VALS)
                                   ENV))))

For EVAL and EVSETQ see Figure 11.
For LOOKUP1 see Figure 3 (not Figure 10, despite Figure 11!).

Figure N6
Implementation of LABELS Using Side Effects
```

## {Primitive Operators}

A primitive operator might be a very complicated object in a "real" LISP implementation; it would probably have machine-language code within it. We are not interested in the details of a particular host machine here; we wish only to present a simple meta-circular definition of PRIMOP and PRIMOP-APPLY. We will notate the procedural object which is the value of CAR (say) in the initial top-level environment <THE-PRIMITIVE-PROCEDURES> "&CAR". This object has no interesting properties except that it is EQ to itself and not to any other object. The initial top-level environment therefore looks like:

(((CAR CDR EQ ATOM NULL NUMBERP + - * ...)
  &CAR &CDR &EQ &ATOM &NULL &NUMBERP &+ &- &* ...))

Given this, we can define PRIMOP and PRIMOP-APPLY as in Figure N7. 

```lisp
(DEFINE (PRIMOP FUN)
        (COND ((EQ FUN '&CAR) T)
              ((EQ FUN '&CDR) T)
              ((EQ FUN '&EQ) T)
              ((EQ FUN '&ATOM) T)
              ((EQ FUN '&NULL) T)
              ((EQ FUN '&NUMBERP) T)
              ((EQ FUN '&+) T)
              ((EQ FUN &-) T)
              ((EQ FUN &*) T)
              ...
              (T NIL)))

(DEFINE (PRIMOP-APPLY FUN ARGS)
        (COND ((EQ FUN '&CAR) (CAR (CAR ARGS)))
              ((EQ FUN '&CDR) (CDR (CAR ARGS)))
              ((EQ FUN '&EQ) (EQ (CAR ARGS) (CADR ARGS)))
              ((EQ FUN '&ATOM) (ATOM (CAR ARGS)))
              ((EQ FUN '&NULL) (NULL (CAR ARGS)))
              ((EQ FUN '&NUMBERP) (NUMBERP (CAR ARGS)))
              ((EQ FUN '&+) (+ (CAR ARGS) (CADR ARGS)))
              ((EQ FUN &-) (- (CAR ARGS) (CADR ARGS)))
              ((EQ FUN &*) (* (CAR ARGS) (CADR ARGS)))
              ...
              (T (ERROR))))

Figure N7
Meta-Circular Definition of PRIMOP and PRIMOP-APPLY
```

## {PROGN Wizardry}



We defined EVPROGN in the way shown in Figure 11 rather than in this "more obvious" way:

(DEFINE (EVPROGN EXPS ENV LASTVAL)
        (COND ((NULL EXPS) LASTVAL)
              (T (EVPROGN (CDR EXPS) ENV (EVAL (CAR EXPS) ENV)))))

for a technical reason: we would like the tail-recursive properties of the code being interpreted to be reflected in the interpretation process. We specifically want recursive calls as the last subform of a PROGN form to be tail-recursive if the PROGN form itself is in a tail-recursive situation. For example, we might write a loop such as:

(DEFINE (PRINTLOOP X) 
        (COND (( = X 0) 'BLASTOFF)
              (T (PROGN (PRINT X)
                        (PRINTLOOP (- X 1))))))

We would like this loop to be iterative, but it can be iterative only if the recursive call to PRINTLOOP is tail-recursive. Our point is that if the "obvious" version of EVPROGN is used in the interpreter, then interpretation of PRINTLOOP will not be tail-recursive because of the "stacking up of EVPROGN frames" (the last call to EVAL from EVPROGN is not tail-recursive). This is unnecessary because EVPROGN does nothing with the last value but return it anyway.
By the way, the use of PROGN in a COND clause as shown above in PRINTLOOP is a very common situation, as is the use of a PROGN as the body of a procedure (cf. George's last experimental version of MAPCAR). As a convenience, most real LISP implementations define extended versions of COND and LAMBDA which implicitly treat clauses (resp. bodies) as PROGN forms (see Figure N8). This allows us to write such things as:

(DEFINE (PRINTLOOP X) 
        (SLEEP 1)
        (COND ((= X 0) 'BLASTOFF)
              (T (PRINT X)
                 (PRINTLOOP (- X 1)))))

```lisp
(DEFINE (EVCOND CLAUSES ENV)
        (COND ((NULL CLAUSES) (ERROR))
              ((EVAL (CAAR CLAUSES) ENV)
               (EVPROGN (CDAR CLAUSES) ENV NIL))
              (T (EVCOND (COR CLAUSES) ENV))))

(DEFINE (APPLY FUN ARGS)
        (COND ((PRIMOP FUN) (PRIMOP-APPLY FUN ARGS))
              ((EQ (CAR FUN) '&PROCEDURE)
               (EVPROGN (CDDR FUN)
                        (BIND (CADR FUN) ARGS (CADDDR FUN))
                        NIL))
              (T (ERROR))))

For EVAL and EVPROGN see Figure 11.

Figure N8
Treating COND Clauses and Procedure Bodies as Implicit PROGN Forms
```

Finally, we note that PROGN is unnecessary except as a programming convenience. Because the language is defined to be executed in applicative order (cf. {Note Normal Order Loses) in [Revised Report]), we can force the sequencing of evaluation, as well as throw away unwanted values, by using LAMBDA-expressions. We first note that

(PROGN e_1 e_2 ... e_N-1 e_N) ≡ (PROGN e_1 (PROGN e_2 ... (PROGN e_N-1 e_N) ... ))

so that we need worry only about PROGN with two subforms: 

(PROGN e_1 e_2) ≡ ((LAMBDA (HUNOZ F) (F))
                   e_1
                   (LAMBDA () e_2))

(see [Imperative] and [Revised Report]).


## {QUOTE Mapping}

What the QUOTE notation achieves is a simple mapping of the entire set of S-expressions into a subset of itself; this mapping is trivially invertible. This is necessary in order to leave some S-expressions left over to represent other things.
This idea may be applied to natural numbers as well. We can "quote" a number by doubling it. In this way every even number represents half of itself, just as the S-expression (QUOTE α) represents the S- expression in its cadr. This leaves all the odd numbers for other purposes. For example, we can define an ordered set of variables and let 3N encode the 'th variable, for N>10. We can also let 31 mean COND, 32 mean LAMBDA, etc. We can then encode a procedure call as 5^f 7^x 11^y 13^z ... where f is the encoding of the procedure and x, y, z, ... are the encodings of the arguments; COND forms and LAMBDA-expressions can be similarly encoded. For example,

(COND ((NULL A) 3) (T 6)) 

might be encoded as the number

```
               10         48 12
         1421 3  ) 6     3  7  )
        3    7    7 )  (5
      (5             11
  1 (5
 3 7
5
```

In this manner we can encode all of the LISP language as natural numbers. This is an example of the technique of "Gödelization". 


## {QUOTE Shafts the Compiler}

We emphasize that it is not the presence of dynamically scoped variables which makes standard LISP difficult for compilers, but the very fact that the LAMBDA-expressions are quoted. It is impossible in general to determine whether a quoted S-expression is intended to be code or just some constant data. Most LISP systems provide another kind of QUOTE called FUNCTION. In LISP 1 [LISP IM] and LISP 1.5 [LISP 1.5M] this used to produce FUNARG objects (we call them &PROCEDURE objects), but in more recent LISP systems [Moon] [Teitelman] an ordinary FUNCTION-expression has been made equivalent to a quoted expression, serving only as a flag to the compiler that the quoted expression is intended as code. However, the introduction of the "'" notation for quoted expressions has led many programmers to prefer the use of QUOTE to FUNCTION for reasons of conciseness. This in turn has required changes to the compiler to specially recognize standard situations where this is used (e.g. the functional argument to MAPCAR), but this patch doesn't solve the problem generally.


## {RPLACA Can Alter CAR Instead}

We have implicitly thought of the RPLACA operation as modifying a cons so as to have a different car. However, there is an interpretation in which RPLACA is thought of as modifying the CAR operator. Taking the car of an object always involves both the CAR operator and the object. When we perform an RPLACA on object denoted by FOO, all we can say is that the value of (CAR FOO) may have changed. It is not necessarily clear what aspect of that expression has changed. Using this idea, we can express RPLACA in terms of SETQ as in Figure N9. Note that we depend on EQ to distinguish different results of CONS.

```lisp
(DEFINE (RPLACA X Y)
        (PROGN ((LAMBDA (OLDCAR)
                        (SETQ CAR
                              (LAMBDA (Z)
                                      (COND ((EQ Z X) Y)
                                            (T (OLDCAR X))))))
                CAR)
               X))

Figure N9
RPLACA in Terms of SETQ Which Modifies CAR
```

## {S-expression Postulates and Notation}


S-expressions form a number system analogous to that for the natural numbers. Each can be used to encode arbitrary strings of symbols by means of "Gödelization", but the S-expression encoding is usually far more convenient than the numerical encoding.
We repeat here the informal characterization of Peano's postulates and the analogous postulates for S-expressions from [Levin]:

#### The Postulates of Arithmetic 
1. Zero is a number.
2. The successor of a number is a number. 3. Zero is not the successor of any number.
4. No two numbers have the same successor.
5. (Induction Principle) Any property which is true for zero, and is such that if it is true for some number it is also true for the successor of that number, it is true for all numbers.

Zero is notated as 0, and the successor of any number N is notated as N'. As a convenience we define alternative notations for numbers other than zero, such as decimal place-value notation. Thus for 0''''''''''''' often write 13.

#### The Postulates for S-expressions 
1. Atoms are S-expressions. 
2. The cons of any two S-expressions is an S-expression. 
3. An atom is not the cons of any two S-expressions. 
4. If α differs from β, or if γ differs from δ, then cons of α and γ differs from cons of β and δ.
5. (Induction Principle) Any property which is true of all atoms, and is such that if it is true for two S-expressions it is also true for their cons, is true for all S-expressions.

Atoms are notated as strings of letters and digits. The cons of two S-expressions α and β is notated (α . β). As a convenience, we define alternative notations for some commonly used forms of S-expression, such as list notation. The atom NIL is called the "empty list"; we write it as (). If (α β γ ... δ) is (the notation for) a list π (where the "..." is meant as a meta-syntactic ellipsis), then the cons of ε and π is written (ε α β ... δ). We also define quotation notation, in which (QUOTE α) is written as 'α.
(This definition of S-expressions applies to "pure LISP", which has no side effects. In Part Two, when the RPLACA and RPLACD operators are introduced, the phrase "the cons of" will not be well-defined.)


## {This ain't A-lists}

Our symbol table routines are not the same as those in LISP 1.5. Their behavior is approximately the same, but the data structures involved differ. The LISP 1.5 routines (PAIRLIS and ASSOC) use the traditional "association list" format:

![fig1.png](fig1.png)

Our routines (BIND and LOOKUP), besides having nicer names, are more efficient because the number of conses performed to bind a given number of variables is usually smaller (we arrange for the environment structure to share the variable lists already contained in LAMBDA-expressions). Morever, the environment is organized into "frames" or "contours", which will be of some utility later. The environment is represented in this form:


![fig2.png](fig2.png)


## {Value Quibble}


"Did he ever return?
 No, he never returned,
 And his fate is still unlearned..."
- The Man Who Never Returned (Charlie on the MTA)

We said "EVAL's purpose is to determine the values of expressions". But what is the value of the expression (DRIVER)? It is certainly not an illegal or useless expression to evaluate, yet it has no value. The purpose of the expression is to cause a certain process to be evolved; it is an "infinite loop", which never returns. This process includes side effects (READ and PRINT) through which it interacts with the user. This situation arises because the system of interest is broken into two parts with independent state: the computer and the user. We will have more to say about this later.


## {Weber}

To continue our GAUSSIAN example (see (Note Gaussian)), we can try to remove the side-effect from RANDOM while avoiding the passing around of SEED by pushing RANDOM up to the top level (see Figure N10). RANDOM-DRIVER takes a function F and an initial seed (reminiscent of <THE-PRIMITIVE - PROCEDURES>), and continually stuffs random numbers into F. Each call to F must produce a new F (a kind of continuation [Reynolds]). Using this, we can arrange for numbers with a "Gaussian" distribution to be generated.

```lisp
(DEFINE (RANDOM-DRIVER F SEED) 
        ((LAMBDA (NEWSEED)
                 (RANDOM-DRIVER (F NEWSEED) NEWSEED))
         ((LAMBDA (Z)
                  (COND ((> Z 0) Z)
                        (T (+ Z -32768.))))
          (* SEED 899.))))

(DEFINE (GAUSSIAN G)
        (WEBER 0 43 G))

(DEFINE (WEBER X N H)
        (COND ((= N 0) (H X))
              (T (LAMBDA (R)
                         (WEBER (+ X R) (- N 1) H)))))

(DEFINE (DRIVER USERFN INITSEED)
        (RANDOM-DRIVER (GAUSSIAN USERFN) INITSEED))

Figure N10
"Gaussian" Pseudo-Random Number Generator without Passing SEED Around
```

In this way, a user function can be provided to DRIVER (along with the initial seed), and the user function will have "Gaussian" numbers stuffed into it. For example:

(DEFINE (PR) (PROGN (PRINT R) P))

(DRIVER P 11)

will print an interminable sequence of "Gaussian" numbers. Notice the structure of the program: the RANDOM procedure calls GAUSSIAN, which in turn calls the user procedure. We have completely everted the overall system. The more layers in the original system piled on top of GAUSSIAN, the more layers will appear inside-out in this version.
Now there are two other funny things about this. One is that we had to use a side effect (PRINT) to get the answer out; the other is that it's hard to make it stop! These problems are related. The structure of RANDOM-DRIVER is an infinite loop, as with all drivers. Because RANDOM-DRIVER never returns a value, there is no way to get an answer out without a side- effect like PRINT. 
We can arrange to signal RANDOM-DRIVER that по more values are desired, and to return a value (see Figure N11). 

```lisp
(DEFINE (RANDOM-DRIVER F SEED)
        (COND ((CAR F) (CDR F))
              (T ((LAMBDA (NEWSEED)
                          (RANDOM-DRIVER ((CDR F) NEWSEED) NEWSEED))
                  ((LAMBDA (Z)
                           (COND ((> Z 0) Z)
                                 (T (+ Z -32768.))))
                   (* SEED 899.))))))

(DEFINE (GAUSSIAN G)
        (WEBER 0 43 G))

(DEFINE (WEBER X N H)
        (COND ((= N 0) (H X))
              (T (CONS NIL
                       (LAMBDA (R)
                               (WEBER (+ X R) (- N 1) H))))))

(DEFINE (DRIVER USERFN)
        (RANDOM-DRIVER (GAUSSIAN USERFN) 43))

Figure N11
"Gaussian" Random-Number Generator "Top Level" without Side Effects
```

Using this new definition, we can write: 

(DEFINE (P R) (CONS T R))

(DRIVER P 11) 

which eventually returns one "Gaussian" number. (Doing something with more than one "Gaussian" number takes a little more work...)
Notice that in order to make this work, RANDOM-DRIVER had to know an awful lot about its functional argument; a fairly complicated protocol had to be developed for handshaking. We might argue that this exercise, while it has indeed removed all obvious side effects, has somewhat tarnished the modularity of the RANDOM program. In any case, the structure of our final program is not exactly what we had in mind when we started.


## {Y-operator}

While the interpreter of Figure 8 cannot DEFINE recursive procedures, it is possible to define recursive procedures by using a variant of the "paradoxical combinator", also known as the Y-operator: 

(DEFINE (Y F)
        ((LAMBDA (G)
                 (LAMBDA (X)
                         ((F (G G)) X)))
         (LAMBDA (G)
                 (LAMBDA (X)
                         ((F (G G)) X)))))

Using this we define the doubly-recursive algorithm for computing the Fibonacci function:

(DEFINE (FIB K) 
        ((Y (LAMBDA (F)
                    (LAMBDA (N)
                            (COND ((= N 0) 1)
                                  ((= N 1) 1)
                                  (T (+ (F (- N 1)) (F (- N 2))))))))
         K))

That this manages to work is truly remarkable. Notice that this is almost identical to the LABEL construct which was actually introduced by LISP 1, though at the time it was invented the implementors didn't realize this correspondence [LISP History].

# References

(Entries marked with a "*" are not referenced in the text.) 

[Church] 
Church, Alonzo. The Calculi of Lambda Conversion. Annals of Mathematics Studies Number 6. Princeton University Press (Princeton, 1941). Reprinted by Klaus Reprint Corp. (New York, 1965).

[Debunking] 
Steele, Guy Lewis Jr. "Debunking the 'Expensive Procedure Call' Myth." Proc. ACM National Conference (Seattle, October 1977),153- 162. Revised as MIT AI Memo 443 (Cambridge, October 1977). 

[Declarative] 
Steele, Guy Lewis Jr. LAMBDA: The Ultimate Declarative. AI Memo 379. MIT AI Lab (Cambridge, November 1976).

[Fischer] 
Fischer, Michael J. "Lambda Calculus Schemata." Proceedings of ACM Conference on Proving Assertions about Programs. SIGPLAN Notices (January 1972).

[Goto] 
Eiichi. Monocopy and Associative Algorithms in an Extended LISP. Information Science Laboratory, University of Tokyo (May 1974). 

[Hewitt and Smith] 
Hewitt, Carl, and Smith, Brian. . "Towards a Programming Apprentice." IEEE Transactions on Software Engineering SE-1, 1 (March 1975), 26-45. 

[Imperative] 
Steele, Guy Lewis Jr., and Sussman, Gerald Jay. LAMBDA: The Ultimate Imperative. AI Memo 353. MIT AI Lab (Cambridge, March 1976). 

[Kleene] 
Kleene, Stephen Cole. Introduction to Metamathematics. Von Nostrand (Princeton, 1950).

[Landin]
Landin, Peter J. "A Correspondence between ALGOL 60 and Church's Lambda-Notation." Comm. ACM 8, 2-3 (February and March 1965).

[Levin] 
Levin, Michael. Mathematical Logic for Computer Scientists. MIT Project MAC TR-131 (Cambridge, June 1974).

[LISP 1M] 
McCarthy, J., Brayton, R., Edwards, D., Fox, P., Hodes, L., Luckham, D., Maling, K., Park, D., and Russell, S. LISP Programmer's Manual. Artifical Intelligence Group, Computation Center and Research Laboratory of Electronics, MIT (Cambridge, March 1960).

[LISP 1.5M ] 
McCarthy, John, et al. LISP 1.5 Programmer's Manual. The MIT Press (Cambridge, 1962). 

[LISP History]
McCarthy, John. "History of LISP." To appear in Proceedings of the SIGPLAN History of Programming Languages Conference, June 1978. 

[McDermott and Sussman]
McDermott, Drew V. and Sussman, Gerald Jay. The CONNIVER Reference Manual. AI Memo 295a. MIT AI Lab (Cambridge, January 1974).

[Moon]
Moon, David A. MacLISP Reference Manual, Revision 0. Project MAC, MIT (Cambridge, April 1974). 

[Moses]
Moses, Joel. The Function of FUNCTION in LISP. AI Lab (Cambridge, June 1970).

[Naur] 
Naur, Peter (ed.), et al. "Revised Report on the Algorithmic Language ALGOL 60." Comm. ACM 6, 1 (January 1963), 1-20.

[Revised Report] 
Steele, Guy Lewis Jr., and Sussman, Gerald Jay. The Revised Report on SCHEME. MIT AI Memo 452 (Cambridge, January 1978). 

[Reynolds]
"Definitional Interpreters for Higher Order Programming Languages." ACM Conference Proceedings 1972. 

[Rulifson]
Rulifson, J.F.. Derksen, J.A., and Waldinger, R.J. QA4: A Procedural Calculus for Intuitive Reasoning. Techical Note 73. Artificial Intelligence Center, Stanford Research Institute (Menlo Park, California, November 1972).

[SCHEME] 
Sussman, Gerald Jay, and Steele, Guy Lewis Jr. SCHEME: An Interpreter for Extended Lambda Calculus. AI Memo 349. MIT AI Lab (Cambridge, December 1975).

[Smith and Hewitt]
Smith, Brian C. and Hewitt, Carl. A PLASMA Primer (draft). MIT AI Lab (Cambridge, October 1975).

[Teitelman] 
Teitelman, Warren. InterLISP Reference Manual. Revised edition. Xerox Palo Alto Research Center (Palo Alto, 1975). 

[Warren]
Warren, David H.D., and Pereira, Luis. "PROLOG: The Language and Its Implementation Compared with LISP." Proceedings of the Symposium on Artifical Intelligence and Programming Languages (Rochester, New York, August 1977). SIGPLAN Notices 12, 8, SIGART Newsletter 64 (August 1977), 109-115.
